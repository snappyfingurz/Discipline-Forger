<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Kingdom: Ascension v4.5</title>
    <!-- Fonts: Cinzel for Titles, Lato for UI -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Lato:wght@400;700&family=Homemade+Apple&family=Orbitron:wght@500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            /* Sky Kingdom Palette */
            --sky-top: #6dd5fa;
            --sky-bottom: #b2fefa;
            --storm-top: #0f172a;
            --storm-bottom: #1e293b;
            
            --glass-bg: rgba(255, 255, 255, 0.2);
            --glass-border: rgba(255, 255, 255, 0.4);
            --text-dark: #1e293b;
            --text-light: #f8fafc;
            
            /* Stat Colors */
            --courage: #4ade80;  /* Forest */
            --strength: #f87171; /* Lava */
            --intellect: #60a5fa; /* Citadel */

            /* Scroll Palette */
            --parchment: #fdf6e3;
            --ink: #2c1a0b;
            --ink-light: #5c4a3b;
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, var(--sky-top), var(--sky-bottom));
            font-family: 'Lato', sans-serif;
            color: var(--text-dark);
            transition: background 2s ease;
        }

        body.storm-mode {
            background: linear-gradient(to bottom, var(--storm-top), var(--storm-bottom));
            color: var(--text-light);
        }

        #canvas-container {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            z-index: 1;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            padding: 24px;
            display: flex; flex-direction: column; justify-content: space-between;
            transition: opacity 0.5s;
        }
        
        #ui-layer.hidden { opacity: 0; pointer-events: none; }

        /* Glass Panel (Top Stats) */
        .glass-panel {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 15px 25px;
            pointer-events: auto;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .glass-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(31, 38, 135, 0.2);
            border-color: rgba(255,255,255,0.6);
        }

        h1, h2, h3, .fantasy-font {
            font-family: 'Cinzel', serif;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 0;
        }

        /* Top Stats Bar */
        #top-bar {
            display: flex; gap: 30px; align-self: center;
            background: rgba(255,255,255,0.25);
            border-radius: 50px;
        }

        .stat-badge {
            display: flex; flex-direction: column; align-items: flex-start;
            min-width: 140px;
        }
        
        .stat-header {
            display: flex; justify-content: space-between; width: 100%;
            font-size: 11px; font-weight: 700; margin-bottom: 6px; letter-spacing: 1px;
        }
        
        .stat-bar-container {
            width: 100%; height: 8px; background: rgba(0,0,0,0.2);
            border-radius: 4px; overflow: hidden;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .stat-fill { 
            height: 100%; width: 0%; 
            transition: width 0.8s cubic-bezier(0.34, 1.56, 0.64, 1); 
            box-shadow: 0 0 10px currentColor;
        }

        /* --- PIRATE SCROLL (Task Panel) --- */
        #scroll-container {
            position: absolute; right: 30px; top: 100px;
            width: 360px;
            pointer-events: auto;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            transform-origin: top right;
            z-index: 50;
        }

        #scroll-container.minimized {
            transform: scale(0.0) translate(200px, -200px);
            opacity: 0; pointer-events: none;
        }

        .scroll-body {
            background: var(--parchment);
            color: var(--ink);
            padding: 40px 30px;
            border-radius: 4px;
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.3),
                inset 0 0 60px rgba(160, 130, 80, 0.2);
            position: relative;
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.5' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100' height='100' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
        }

        /* Top and Bottom Rollers */
        .scroll-body::before, .scroll-body::after {
            content: ''; position: absolute; left: -10px; right: -10px; height: 20px;
            background: #e3d2a8;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4), inset 0 2px 5px rgba(255,255,255,0.4);
            z-index: 2;
        }
        .scroll-body::before { top: -10px; }
        .scroll-body::after { bottom: -10px; }

        .scroll-header {
            text-align: center; border-bottom: 2px solid var(--ink-light);
            padding-bottom: 10px; margin-bottom: 15px;
        }
        .scroll-header h2 { font-size: 24px; color: var(--ink); text-shadow: none; }
        .scroll-date { font-family: 'Homemade Apple', cursive; color: var(--ink-light); font-size: 14px; margin-top: 5px; }

        #task-list {
            max-height: 300px; overflow-y: auto; padding-right: 5px; margin-bottom: 20px;
        }
        
        #task-list::-webkit-scrollbar { width: 6px; }
        #task-list::-webkit-scrollbar-thumb { background: var(--ink-light); border-radius: 3px; }
        
        .task-item {
            font-family: 'Lato', sans-serif;
            background: rgba(255,255,255,0.4);
            padding: 10px; margin-bottom: 8px; 
            border-bottom: 1px dashed var(--ink-light);
            display: flex; align-items: center; justify-content: space-between;
            cursor: pointer; transition: all 0.2s;
            color: var(--ink);
            position: relative;
            overflow: hidden;
        }
        .task-item:hover { 
            transform: translateX(4px); 
            background: rgba(255,255,255,0.7); 
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .task-item.completed { opacity: 0.5; text-decoration: line-through; background: rgba(255,255,255,0.2); }

        /* Minimize Button */
        #toggle-scroll-btn {
            position: absolute; top: 100px; right: 30px;
            width: 45px; height: 45px;
            background: var(--parchment);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            cursor: pointer; z-index: 60; pointer-events: auto;
            border: 2px solid #e3d2a8;
            font-size: 18px; color: var(--ink);
            transition: all 0.3s;
        }
        #toggle-scroll-btn:hover { transform: scale(1.1); }
        
        /* Styled Inputs */
        input.scroll-input {
            background: transparent; border: none; border-bottom: 2px solid var(--ink-light);
            font-family: 'Lato', sans-serif;
            font-weight: bold;
            color: var(--ink);
            font-size: 14px; padding: 5px; width: 100%; outline: none;
        }
        
        /* Custom Select Styling */
        .select-wrapper {
            position: relative;
            width: 70%;
        }
        select.scroll-input {
            width: 100%;
            appearance: none;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.3); 
            border: none; 
            border-bottom: 2px solid var(--ink-light);
            font-family: 'Lato', sans-serif;
            color: var(--ink);
            font-size: 12px; padding: 5px; outline: none;
            cursor: pointer;
        }
        .select-wrapper::after {
            content: 'â–¼';
            font-size: 10px;
            color: var(--ink-light);
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
        }

        input.scroll-input::placeholder { color: rgba(44, 26, 11, 0.4); font-style: italic; }
        
        button.scroll-btn {
            background: var(--ink); color: var(--parchment);
            border: none; padding: 8px 16px; border-radius: 4px;
            font-family: 'Cinzel'; cursor: pointer;
            transition: transform 0.1s; margin-left: 5px;
            flex-grow: 1;
        }
        button.scroll-btn:hover { transform: scale(1.05); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }

        /* Controls & Navigation */
        #biome-label {
            position: absolute; bottom: 40px; left: 40px; 
            text-align: left; pointer-events: none; opacity: 0; transition: opacity 0.5s;
            z-index: 20;
        }
        #biome-label h1 {
            font-size: 64px; margin: 0; line-height: 1;
            text-shadow: 0 0 25px currentColor, 0 0 10px black;
        }
        #biome-desc {
            color: white; 
            letter-spacing: 4px; 
            text-transform: uppercase; 
            font-size: 14px; 
            opacity: 0.9;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
        }

        #back-btn {
            position: fixed; top: 24px; left: 24px;
            z-index: 100; display: none; pointer-events: auto;
            background: rgba(255, 255, 255, 0.9); border-radius: 30px;
            padding: 12px 30px; border: none; font-weight: bold; cursor: pointer;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            font-family: 'Cinzel'; transition: all 0.2s;
            color: var(--text-dark);
            border: 1px solid rgba(0,0,0,0.1);
        }
        #back-btn:hover { transform: scale(1.05); box-shadow: 0 8px 25px rgba(0,0,0,0.15); }

        #action-btn {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            padding: 20px 60px; font-size: 20px; border-radius: 50px;
            background: linear-gradient(135deg, #FF9966 0%, #FF5E62 100%);
            border: 2px solid rgba(255,255,255,0.5);
            color: white; box-shadow: 0 10px 40px rgba(255, 94, 98, 0.5);
            pointer-events: auto; transition: all 0.3s;
            overflow: hidden;
            text-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 80;
        }
        #action-btn:hover { transform: translateX(-50%) scale(1.05); box-shadow: 0 15px 50px rgba(255, 94, 98, 0.7); }

        /* Battle Overlay */
        #battle-ui {
            position: absolute; bottom: 10%; left: 50%; transform: translateX(-50%);
            display: none; flex-direction: column; align-items: center; z-index: 50;
            pointer-events: auto; width: 100%;
        }
        .battle-msg {
            font-size: 32px; color: #fff; text-shadow: 0 0 20px rgba(0,0,0,0.8);
            font-family: 'Cinzel', serif;
            opacity: 0; transform: translateY(20px);
            margin-bottom: 20px;
        }
        .battle-controls {
            display: flex; gap: 20px; margin-top: 20px;
            opacity: 0; transform: translateY(20px);
        }
        .battle-btn {
            background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.3);
            color: white; padding: 15px 30px; border-radius: 8px; cursor: pointer;
            font-family: 'Cinzel'; font-size: 14px; text-transform: uppercase;
            transition: all 0.2s; backdrop-filter: blur(5px);
            display: flex; flex-direction: column; align-items: center; gap: 5px;
        }
        .battle-btn:hover { transform: translateY(-5px); border-color: white; background: rgba(0,0,0,0.8); }
        .battle-btn[disabled] { opacity: 0.3; cursor: not-allowed; transform: none; border-color: #555; }
        .battle-btn i { font-size: 20px; margin-bottom: 5px; }

        /* CINEMATIC RED CURTAINS */
        .curtain {
            position: fixed; top: 0; height: 100%; width: 51%; 
            background: repeating-linear-gradient(90deg, #4a0000 0%, #750000 5%, #9e0000 10%, #750000 15%, #4a0000 20%);
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9), 0 0 50px rgba(0,0,0,0.5);
            z-index: 200; transition: transform 2.0s cubic-bezier(0.77, 0, 0.175, 1);
            transform: scaleX(0);
        }
        #curtain-left { left: 0; transform-origin: left; border-right: 2px solid #300000; }
        #curtain-right { right: 0; transform-origin: right; border-left: 2px solid #300000; }
        .curtain.closed { transform: scaleX(1); }

        /* Modal */
        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(8px);
            z-index: 100; display: none; justify-content: center; align-items: center;
        }
        .modal-card {
            background: #fff; padding: 50px; border-radius: 20px;
            text-align: center; max-width: 450px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            border: 1px solid rgba(0,0,0,0.1);
        }
        .modal-card h2 { font-size: 36px; margin-bottom: 10px; background: -webkit-linear-gradient(#4facfe, #00f2fe); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #ffffff, #e0f7fa); color: #0288d1; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-family: 'Cinzel', serif; letter-spacing: 2px;
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <div id="curtain-left" class="curtain"></div>
    <div id="curtain-right" class="curtain"></div>

    <div id="loader">
        <h2 style="margin-bottom: 10px;">Sky Kingdom v4.5</h2>
        <div style="font-size: 12px; opacity: 0.6;">Awakening the Golem...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="glass-panel" id="top-bar">
            <div class="stat-badge">
                <div class="stat-header">
                    <span style="color:var(--courage)"><i class="fas fa-tree"></i> COURAGE</span>
                    <span id="val-courage">0/0</span>
                </div>
                <div class="stat-bar-container">
                    <div class="stat-fill" id="bar-courage" style="background: var(--courage)"></div>
                </div>
            </div>
            <div class="stat-badge">
                <div class="stat-header">
                    <span style="color:var(--strength)"><i class="fas fa-fire"></i> STRENGTH</span>
                    <span id="val-strength">0/0</span>
                </div>
                <div class="stat-bar-container">
                    <div class="stat-fill" id="bar-strength" style="background: var(--strength)"></div>
                </div>
            </div>
            <div class="stat-badge">
                <div class="stat-header">
                    <span style="color:var(--intellect)"><i class="fas fa-cube"></i> INTELLECT</span>
                    <span id="val-intellect">0/0</span>
                </div>
                <div class="stat-bar-container">
                    <div class="stat-fill" id="bar-intellect" style="background: var(--intellect)"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="toggle-scroll-btn" onclick="toggleScroll()">
        <i class="fas fa-scroll"></i>
    </div>

    <div id="scroll-container">
        <div class="scroll-body">
            <div class="scroll-header">
                <h2 class="fantasy-font" id="scroll-title">Captain's Log</h2>
                <div class="scroll-date" id="current-date">October 24th, Year of the Sky</div>
            </div>
            <div id="task-list"></div>
            <div style="margin-top: 15px; border-top: 1px dashed var(--ink-light); padding-top: 15px;">
                <input type="text" class="scroll-input" id="task-input" placeholder="Draft new orders..." autocomplete="off">
                <div class="input-group" style="display: flex; gap: 5px; margin-top: 10px;">
                    <div class="select-wrapper">
                        <select id="task-type" class="scroll-input">
                            <option value="courage">Whispering Woods</option>
                            <option value="strength">Iron Sanctum</option>
                            <option value="intellect">Citadel of Logic</option>
                            <option value="campfire">Resting Grounds</option>
                        </select>
                    </div>
                    <button class="scroll-btn" onclick="addTask()">ADD</button>
                </div>
            </div>
        </div>
    </div>

    <div id="biome-label">
        <h1 id="biome-name">Title</h1>
        <p id="biome-desc">Description</p>
    </div>

    <button id="back-btn" onclick="returnToMap()"><i class="fas fa-chevron-left"></i> [ESC] Return</button>
    <button id="action-btn" class="fantasy-font" onclick="initiateBattle()">Storm Ritual</button>

    <div id="battle-ui">
        <div class="battle-msg" id="battle-msg">The Sky Kraken Descends...</div>
        <div class="battle-controls" id="battle-controls">
            <button class="battle-btn" id="btn-courage" onclick="performAttack('courage')" style="border-color:var(--courage)">
                <i class="fas fa-shield-alt" style="color:var(--courage)"></i> Bravery <span id="ammo-courage"></span>
            </button>
            <button class="battle-btn" id="btn-strength" onclick="performAttack('strength')" style="border-color:var(--strength)">
                <i class="fas fa-gavel" style="color:var(--strength)"></i> Force <span id="ammo-strength"></span>
            </button>
            <button class="battle-btn" id="btn-intellect" onclick="performAttack('intellect')" style="border-color:var(--intellect)">
                <i class="fas fa-brain" style="color:var(--intellect)"></i> Logic <span id="ammo-intellect"></span>
            </button>
        </div>
    </div>

    <div id="modal-overlay">
        <div class="modal-card">
            <h2 id="modal-title" class="fantasy-font">Victory</h2>
            <p id="modal-msg" style="line-height: 1.6; color: #555;">The realm prospers.</p>
            <button class="scroll-btn" style="margin-top: 20px; font-size: 16px; padding: 10px 30px;" onclick="closeModal()">Continue</button>
        </div>
    </div>

<script>
    /* =========================================
       GAME STATE & CONFIG
       ========================================= */
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    document.getElementById('current-date').innerText = new Date().toLocaleDateString('en-US', options);

    const state = {
        tasks: [
            { text: "Visit the Resting Grounds", type: "campfire", completed: false },
            { text: "Scout the Whispering Woods", type: "courage", completed: false },
            { text: "Visit the Iron Sanctum", type: "strength", completed: false },
            { text: "Explore the Citadel of Logic", type: "intellect", completed: false }
        ],
        view: 'map',
        isBattling: false,
        mobs: [],
        highlightedBiome: null,
        lavaHeart: null,
        bossParts: [],
        fireParticles: [],
        lastLook: {x:0, y:0, z:0},
        ammo: { courage: 0, strength: 0, intellect: 0 }
    };

    const CONFIG = {
        colors: {
            skyTop: 0x6dd5fa,
            skyBottom: 0xb2fefa,
            stormTop: 0x0f172a,
            stormBottom: 0x1e293b,
            
            forest: 0x4ade80,
            lava: 0xf87171,
            citadel: 0x60a5fa,
            campfire: 0xffaa00
        }
    };

    const BIOME_DATA = {
        forest: { 
            name: "Whispering Woods", stat: "courage", color: CONFIG.colors.forest,
            titleColor: "#4ade80", desc: "Forge Courage", font: "'Cinzel', serif" 
        },
        lava: { 
            name: "Iron Sanctum", stat: "strength", color: CONFIG.colors.lava,
            titleColor: "#f87171", desc: "Build Strength", font: "'Cinzel', serif"
        },
        citadel: { 
            name: "Citadel of Logic", stat: "intellect", color: CONFIG.colors.citadel,
            titleColor: "#60a5fa", desc: "Sharpen Intellect", font: "'Cinzel', serif"
        },
        campfire: {
            name: "The Resting Grounds", stat: "campfire", color: 0xffaa00,
            titleColor: "#ffaa00", desc: "Discipline & Promise", font: "'Cinzel', serif"
        }
    };

    /* =========================================
       THREE.JS SETUP
       ========================================= */
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(CONFIG.colors.skyBottom);
    scene.fog = new THREE.Fog(CONFIG.colors.skyBottom, 30, 150);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 50, 70); 
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9);
    hemiLight.position.set(0, 50, 0);
    scene.add(hemiLight);

    const sunLight = new THREE.DirectionalLight(0xffdfba, 1.2);
    sunLight.position.set(50, 80, 30);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 200;
    scene.add(sunLight);

    const cursorLight = new THREE.PointLight(0xffe0b2, 1.5, 20);
    cursorLight.position.set(0, 10, 0);
    scene.add(cursorLight);

    /* =========================================
       ASSET GENERATION
       ========================================= */
    const boxGeo = new THREE.BoxGeometry(1, 1, 1);
    
    function createVoxel(color, x, y, z, parent, scale={x:1,y:1,z:1}) {
        const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8, flatShading: true });
        const mesh = new THREE.Mesh(boxGeo, mat);
        mesh.position.set(x, y, z);
        mesh.scale.set(scale.x, scale.y, scale.z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        if(parent) parent.add(mesh);
        return mesh;
    }

    function createEmissiveVoxel(color, x, y, z, parent, scale={x:1,y:1,z:1}, intensity=1) {
        const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: intensity, flatShading: true, roughness: 0.2 });
        const mesh = new THREE.Mesh(boxGeo, mat);
        mesh.position.set(x, y, z);
        mesh.scale.set(scale.x, scale.y, scale.z);
        mesh.castShadow = true;
        if(parent) parent.add(mesh);
        return mesh;
    }

    /* =========================================
       WORLD BUILDER
       ========================================= */
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    const biomes = {
        forest: new THREE.Group(),
        lava: new THREE.Group(),
        citadel: new THREE.Group(),
        campfire: new THREE.Group() 
    };
    
    // Add to worldGroup
    worldGroup.add(biomes.forest, biomes.lava, biomes.citadel, biomes.campfire);

    function initWorld() {
        // Clear existing
        biomes.forest.clear();
        biomes.lava.clear();
        biomes.citadel.clear();
        biomes.campfire.clear();
        state.mobs = [];
        state.fireParticles = [];

        // Reset positions
        biomes.forest.position.set(-20, 0, 10); biomes.forest.rotation.set(0,0,0);
        biomes.lava.position.set(20, -2, 10); biomes.lava.rotation.set(0,0,0);
        biomes.citadel.position.set(0, 6, -15); biomes.citadel.rotation.set(0,0,0);
        biomes.campfire.position.set(0, -2, 5); biomes.campfire.rotation.set(0,0,0);

        biomes.forest.userData = { id: 'forest', baseY: 0 };
        biomes.lava.userData = { id: 'lava', baseY: -2 };
        biomes.citadel.userData = { id: 'citadel', baseY: 6 };
        biomes.campfire.userData = { id: 'campfire', baseY: -2 };

        buildForest();
        buildLava();
        buildCitadel();
        buildCampfire();
    }

    // --- 1. WHISPERING WOODS ---
    function buildForest() {
        const g = biomes.forest;
        for(let x=-7; x<7; x++) for(let z=-7; z<7; z++) {
            if(x*x+z*z > 40) continue;
            const col = Math.random() > 0.8 ? 0x388e3c : 0x2e7d32; 
            createVoxel(col, x, 0, z, g); 
            createVoxel(0x5d4037, x, -1, z, g); 
            if(Math.random()>0.85) createVoxel(0x4e342e, x, -2-Math.random(), z, g, {x:0.5,y:2,z:0.5});
        }
        for(let i=0; i<15; i++) {
            const tx=(Math.random()*10-5), tz=(Math.random()*10-5);
            createVoxel(0x3e2723, tx, 1.5, tz, g, {x:0.6, y:3, z:0.6}); 
            createVoxel(0x4ade80, tx, 3.5, tz, g, {x:1.6, y:1.5, z:1.6}); 
            if(Math.random()>0.7) createEmissiveVoxel(0xffff00, tx+0.5, 4, tz, g, {x:0.2,y:0.2,z:0.2}, 2);
            if(Math.random() > 0.5) createVoxel(0x22c55e, tx + 1, 0.5, tz + 1, g, {x:0.8, y:0.8, z:0.8});
        }
        const pGeo = new THREE.BufferGeometry();
        const pPos = [];
        for(let i=0; i<40; i++) pPos.push((Math.random()-0.5)*12, Math.random()*6+2, (Math.random()-0.5)*12);
        pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
        const fireflies = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0xccff00, size:0.25, transparent:true}));
        g.add(fireflies);
        g.userData.particles = fireflies;

        for(let i=0; i<6; i++) {
            const rabbit = new THREE.Group();
            createVoxel(0xffffff, 0, 0.25, 0, rabbit, {x:0.4, y:0.4, z:0.6}); 
            createVoxel(0xffffff, 0, 0.55, 0.2, rabbit, {x:0.3, y:0.3, z:0.3}); 
            createVoxel(0xffc0cb, -0.1, 0.8, 0.2, rabbit, {x:0.1, y:0.5, z:0.1});
            createVoxel(0xffc0cb, 0.1, 0.8, 0.2, rabbit, {x:0.1, y:0.5, z:0.1});
            createVoxel(0xffffff, 0, 0.3, -0.35, rabbit, {x:0.15, y:0.15, z:0.15});
            createVoxel(0x000000, 0.1, 0.6, 0.36, rabbit, {x:0.05, y:0.05, z:0.02}); 
            createVoxel(0x000000, -0.1, 0.6, 0.36, rabbit, {x:0.05, y:0.05, z:0.02});
            rabbit.position.set((Math.random()-0.5)*8, 1, (Math.random()-0.5)*8);
            rabbit.userData = { type: 'rabbit', baseY: 1, state: 'idle', timer: Math.random() * 2, jumpTarget: new THREE.Vector3() };
            g.add(rabbit);
            state.mobs.push(rabbit);
        }
    }

    // --- 2. IRON SANCTUM ---
    function buildLava() {
        const g = biomes.lava;
        for(let x=-8; x<8; x++) for(let z=-8; z<8; z++) {
            if(x*x+z*z > 50) continue;
            const isRiver = Math.abs(x*0.5 + Math.sin(z*0.5)*1.5) < 1.5;
            if(isRiver && x*x+z*z < 45) {
                 const m = createEmissiveVoxel(0xff4500, x, -0.5, z, g, {x:1,y:0.8,z:1}, 0.8);
                 m.userData.isLava = true; m.userData.origY = -0.5;
            } else {
                const h = Math.random() * 0.8;
                createVoxel(0x1a1a1a, x, h, z, g, {x:1, y:1+h, z:1});
            }
            createVoxel(0x0f0f0f, x, -1.5, z, g); 
        }
        
        const heartGroup = new THREE.Group();
        heartGroup.position.set(0, 3, 0);
        g.add(heartGroup);
        const coreGeo = new THREE.IcosahedronGeometry(1.2, 1);
        const coreMat = new THREE.MeshStandardMaterial({color: 0xff4500, emissive: 0xff0000, emissiveIntensity: 3, roughness: 0.1, flatShading: true});
        const core = new THREE.Mesh(coreGeo, coreMat);
        heartGroup.add(core);
        const shell = new THREE.Mesh(new THREE.IcosahedronGeometry(1.8, 0), new THREE.MeshStandardMaterial({color: 0x000000, transparent: true, opacity: 0.4, wireframe: true}));
        heartGroup.add(shell);
        const pLight = new THREE.PointLight(0xff0000, 2, 15);
        heartGroup.add(pLight);
        state.lavaHeart = { group: heartGroup, core: core, light: pLight };

        for(let i=0; i<5; i++) {
            const slime = new THREE.Group();
            createEmissiveVoxel(0xff0000, 0, 0.4, 0, slime, {x:0.5, y:0.5, z:0.5}, 2); // Core
            const shellGeo = new THREE.BoxGeometry(1, 1, 1);
            const shellMat = new THREE.MeshStandardMaterial({color: 0xff4500, transparent: true, opacity: 0.7, roughness: 0.1, emissive: 0xff4500, emissiveIntensity: 0.2});
            const shellMesh = new THREE.Mesh(shellGeo, shellMat);
            shellMesh.position.set(0, 0.4, 0);
            shellMesh.scale.set(0.8, 0.7, 0.8);
            slime.add(shellMesh);
            createVoxel(0xffffff, 0.15, 0.5, 0.4, slime, {x:0.1, y:0.1, z:0.1});
            createVoxel(0xffffff, -0.15, 0.5, 0.4, slime, {x:0.1, y:0.1, z:0.1});
            createVoxel(0x000000, 0.15, 0.5, 0.45, slime, {x:0.05, y:0.05, z:0.05});
            createVoxel(0x000000, -0.15, 0.5, 0.45, slime, {x:0.05, y:0.05, z:0.05});
            slime.position.set((Math.random()-0.5)*8, 1, (Math.random()-0.5)*8);
            slime.userData = { type: 'slime', baseY: 1, state: 'idle', timer: Math.random()*2, jumpTarget: new THREE.Vector3() };
            g.add(slime);
            state.mobs.push(slime);
        }

        const hulk = new THREE.Group();
        createVoxel(0x2a2a2a, 0, 1.2, 0, hulk, {x:1.4, y:1.2, z:1.0}); // Main
        createVoxel(0x444444, 0, 1.6, -0.2, hulk, {x:1.2, y:0.5, z:0.8}); // Upper Back
        createEmissiveVoxel(0xff4500, 0, 1.2, 0.51, hulk, {x:0.8, y:0.8, z:0.1}, 2); // Chest glow
        createEmissiveVoxel(0xff0000, 0.4, 1.0, 0.51, hulk, {x:0.2, y:0.6, z:0.1}, 2);
        createEmissiveVoxel(0xff0000, -0.4, 1.0, 0.51, hulk, {x:0.2, y:0.6, z:0.1}, 2);
        createVoxel(0x111111, 0, 1.9, 0, hulk, {x:0.8, y:0.6, z:0.8});
        createEmissiveVoxel(0xffaa00, 0.2, 2.0, 0.4, hulk, {x:0.15, y:0.1, z:0.1}, 5); 
        createEmissiveVoxel(0xffaa00, -0.2, 2.0, 0.4, hulk, {x:0.15, y:0.1, z:0.1}, 5); 
        createEmissiveVoxel(0xff3300, 0, 1.7, 0.41, hulk, {x:0.4, y:0.1, z:0.1}, 3); 
        const legL = new THREE.Group(); legL.position.set(-0.4, 0.6, 0);
        createVoxel(0x333333, 0, -0.3, 0, legL, {x:0.5, y:0.6, z:0.6}); 
        createVoxel(0x1a1a1a, 0, -0.9, 0.1, legL, {x:0.45, y:0.6, z:0.5}); 
        createEmissiveVoxel(0xff4500, 0, -0.6, 0.31, legL, {x:0.1, y:0.4, z:0.1}, 2); 
        hulk.add(legL);
        const legR = new THREE.Group(); legR.position.set(0.4, 0.6, 0);
        createVoxel(0x333333, 0, -0.3, 0, legR, {x:0.5, y:0.6, z:0.6}); 
        createVoxel(0x1a1a1a, 0, -0.9, 0.1, legR, {x:0.45, y:0.6, z:0.5}); 
        hulk.add(legR);
        const armL = new THREE.Group(); armL.position.set(-0.9, 1.6, 0);
        createVoxel(0x333333, 0, 0, 0, armL, {x:0.6, y:0.6, z:0.6}); 
        createVoxel(0x2a2a2a, 0, -0.6, 0, armL, {x:0.4, y:0.7, z:0.4}); 
        createVoxel(0x1a1a1a, 0, -1.3, 0.2, armL, {x:0.5, y:0.7, z:0.5}); 
        createEmissiveVoxel(0xff0000, 0, -1.0, 0.2, armL, {x:0.1, y:0.1, z:0.45}, 2); 
        hulk.add(armL);
        const armR = new THREE.Group(); armR.position.set(0.9, 1.6, 0);
        createVoxel(0x333333, 0, 0, 0, armR, {x:0.6, y:0.6, z:0.6}); 
        createVoxel(0x2a2a2a, 0, -0.6, 0, armR, {x:0.4, y:0.7, z:0.4}); 
        createVoxel(0x1a1a1a, 0, -1.3, 0.2, armR, {x:0.5, y:0.7, z:0.5}); 
        hulk.add(armR);
        const chainGroup = new THREE.Group();
        chainGroup.position.set(0.6, 0.2, 0.5);
        for(let k=0; k<6; k++) {
            const link = createEmissiveVoxel(0xff5722, 0, 0, k*0.3, chainGroup, {x:0.25, y:0.08, z:0.4}, 2);
            link.rotation.y = Math.random();
        }
        hulk.add(chainGroup);
        hulk.userData.chain = chainGroup;
        hulk.position.set(4, 0.1, 4); 
        hulk.userData = { type: 'hulk', baseY: 0.1, timer: 0, dir: new THREE.Vector3(0.02, 0, 0.02) };
        g.add(hulk);
        state.mobs.push(hulk);
    }

    // --- 3. CITADEL ---
    function buildCitadel() {
        const g = biomes.citadel;
        g.children = []; 
        for(let x=-6; x<6; x++) for(let z=-6; z<6; z++) {
            const dist = Math.sqrt(x*x + z*z);
            if(dist > 5.5) continue;
            createVoxel(0xf8fafc, x, 0, z, g, {x:1, y:1, z:1});
            createVoxel(0x94a3b8, x, -1, z, g, {x:0.9, y:1, z:0.9}); 
            if(Math.abs(x) < 2 && z > 0) createVoxel(0xcbd5e1, x, 0.51, z, g, {x:0.9, y:0.05, z:0.9}); 
        }
        const castle = new THREE.Group();
        castle.position.set(0, 0.5, 0);
        g.add(castle);
        createVoxel(0xe2e8f0, 0, 4, 0, castle, {x:3, y:8, z:3});
        function createSpire(x, z, height, width, color) {
            const geo = new THREE.ConeGeometry(width, height, 4);
            const mat = new THREE.MeshStandardMaterial({color: color, flatShading: true, roughness: 0.2});
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, height/2 + 8, z);
            castle.add(mesh);
            const tipGeo = new THREE.ConeGeometry(width/4, 1, 4);
            const tipMat = new THREE.MeshBasicMaterial({color: 0x60a5fa});
            const tip = new THREE.Mesh(tipGeo, tipMat);
            tip.position.set(0, height/2 + 0.5, 0);
            mesh.add(tip);
        }
        createSpire(0, 0, 12, 2.5, 0x1e3a8a); 
        createSpire(-2.5, -2.5, 8, 1, 0x2563eb);
        createSpire(2.5, -2.5, 8, 1, 0x2563eb);
        createSpire(-2.5, 2.5, 8, 1, 0x2563eb);
        createSpire(2.5, 2.5, 8, 1, 0x2563eb);
        const gate = new THREE.Group();
        gate.position.set(0, 1, 4.5);
        createVoxel(0xffffff, -1.5, 2, 0, gate, {x:0.5, y:4, z:0.5});
        createVoxel(0xffffff, 1.5, 2, 0, gate, {x:0.5, y:4, z:0.5});
        createVoxel(0xffffff, 0, 4.2, 0, gate, {x:3.5, y:0.5, z:0.5});
        const lightPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(3, 4),
            new THREE.MeshBasicMaterial({color: 0x60a5fa, side: THREE.DoubleSide, transparent: true, opacity: 0.3})
        );
        lightPlane.position.y = 2;
        gate.add(lightPlane);
        castle.add(gate);
        const wallRing = new THREE.Group();
        for(let i=0; i<12; i++) {
            const angle = (i/12) * Math.PI * 2;
            const segment = createVoxel(0xcbd5e1, Math.cos(angle)*7, 0, Math.sin(angle)*7, wallRing, {x:1.5, y:2, z:0.5});
            segment.rotation.y = -angle;
        }
        g.add(wallRing);
        g.userData.wallRing = wallRing;
        for(let i=0; i<4; i++) {
            const wiz = new THREE.Group();
            createVoxel(0x2563eb, 0, 0.7, 0, wiz, {x:0.5, y:1.4, z:0.4}); 
            createVoxel(0x1e3a8a, 0, 0.6, -0.25, wiz, {x:0.7, y:1.2, z:0.2}); 
            createVoxel(0xffd700, 0, 1.6, 0, wiz, {x:0.35, y:0.4, z:0.35}); 
            createVoxel(0xe2e8f0, 0, 1.45, 0.2, wiz, {x:0.25, y:0.2, z:0.1}); 
            const hatGeo = new THREE.ConeGeometry(0.35, 0.8, 8);
            const hatMat = new THREE.MeshStandardMaterial({color: 0x1e3a8a, flatShading:true});
            const hat = new THREE.Mesh(hatGeo, hatMat);
            hat.position.set(0, 2.1, 0);
            wiz.add(hat);
            createVoxel(0x1e3a8a, 0, 1.8, 0, wiz, {x:0.8, y:0.05, z:0.8}); 
            createVoxel(0x2563eb, 0.35, 1.0, 0.1, wiz, {x:0.2, y:0.6, z:0.2}).rotation.x = -Math.PI/4; 
            const book = new THREE.Group();
            createVoxel(0x78350f, 0, 0, 0, book, {x:0.3, y:0.4, z:0.05}); 
            createVoxel(0xffffff, 0, 0, 0.04, book, {x:0.25, y:0.35, z:0.02}); 
            book.position.set(0.4, 1.1, 0.4);
            book.rotation.set(-0.5, -0.3, 0);
            wiz.add(book);
            wiz.userData.book = book;
            wiz.position.set((Math.random()-0.5)*2, 1, 2 + Math.random()*2);
            const angle = Math.random() * Math.PI * 2;
            wiz.userData = { type: 'wizard', baseY: 1, hoverOffset: Math.random() * 10, dir: new THREE.Vector3(Math.cos(angle)*0.015, 0, Math.sin(angle)*0.015), timer: Math.random() * 3 };
            g.add(wiz);
            state.mobs.push(wiz);
        }
    }

    // --- 4. CAMPFIRE ---
    function buildCampfire() {
        const g = biomes.campfire;
        for(let x=-5; x<5; x++) for(let z=-5; z<5; z++) {
            if(x*x + z*z > 20) continue;
            createVoxel(0x5c8001, x, 0, z, g); 
            createVoxel(0x3e2723, x, -1, z, g); 
        }
        const fireCenter = new THREE.Group();
        for(let i=0; i<8; i++) {
            const angle = (i/8)*Math.PI*2;
            createVoxel(0x888888, Math.cos(angle)*0.8, 0.2, Math.sin(angle)*0.8, fireCenter, {x:0.4, y:0.3, z:0.4}).rotation.y = Math.random();
        }
        const logColor = 0x5d4037; 
        let l = createVoxel(logColor, 0, 0.3, 0.3, fireCenter, {x:1.6, y:0.3, z:0.4}); l.rotation.x = 0.2; 
        l = createVoxel(logColor, 0.3, 0.3, -0.3, fireCenter, {x:1.6, y:0.3, z:0.4}); l.rotation.y = 2.0; l.rotation.x = 0.2;
        l = createVoxel(logColor, -0.3, 0.5, -0.2, fireCenter, {x:1.6, y:0.3, z:0.4}); l.rotation.y = -2.0; l.rotation.x = -0.2;
        const fireLight = new THREE.PointLight(0xffaa00, 2, 12);
        fireLight.position.set(0, 1.5, 0);
        fireCenter.add(fireLight);
        g.userData.fireLight = fireLight;
        g.add(fireCenter);
        state.fireParticles = [];
        for(let i=0; i<40; i++) {
            const p = createEmissiveVoxel(0xffaa00, 0, 0, 0, fireCenter, {x:0.2, y:0.2, z:0.2}, 1);
            resetParticle(p);
            state.fireParticles.push(p);
        }
        const tentPos = [{x:-3, z:2}, {x:3, z:-1}, {x:-1, z:-3}];
        tentPos.forEach(p => {
            const tent = new THREE.Group();
            tent.position.set(p.x, 0.5, p.z);
            tent.rotation.y = Math.atan2(-p.x, -p.z);
            const t1 = createVoxel(0xd4a373, 0, 0.5, 0, tent, {x:1.5, y:1, z:1.5});
            t1.rotation.x = Math.PI/4;
            createVoxel(0x8d6e63, 0, 0.1, 0.5, tent, {x:0.8, y:0.2, z:1.2});
            g.add(tent);
        });
        for(let i=0; i<3; i++) {
            const adv = new THREE.Group();
            createVoxel(0x8d6e63, 0, 0.4, 0, adv, {x:0.5, y:0.6, z:0.5}); 
            createVoxel(0xffcc80, 0, 0.9, 0, adv, {x:0.3, y:0.3, z:0.3}); 
            adv.position.set((Math.random()-0.5)*3, 0.3, (Math.random()-0.5)*3);
            adv.lookAt(0,0,0);
            g.add(adv);
        }
    }

    function resetParticle(p) {
        p.position.set((Math.random()-0.5)*0.6, 0.5, (Math.random()-0.5)*0.6);
        p.scale.set(0.3, 0.3, 0.3);
        p.material.color.setHex(0xffff00); 
        p.material.emissive.setHex(0xffff00);
        p.userData = {
            life: 1.0, 
            speedY: 0.02 + Math.random()*0.03,
            drift: (Math.random()-0.5)*0.01
        };
        p.visible = true;
    }

    // --- 5. BRIDGES ---
    function buildBridges() {
        const bridgeGroup = new THREE.Group();
        scene.add(bridgeGroup);
        function makeBridge(start, end) {
            const dist = start.distanceTo(end);
            const steps = Math.floor(dist * 1.5);
            for(let i=0; i<=steps; i++) {
                const t = i/steps;
                const p = new THREE.Vector3().lerpVectors(start, end, t);
                p.y += Math.sin(t * Math.PI) * 1.0; 
                createVoxel(0x8d6e63, p.x, p.y, p.z, bridgeGroup, {x:1, y:0.2, z:1});
                if(i%8===0 && i!==0 && i!==steps) {
                    createEmissiveVoxel(0xffaa00, p.x, p.y+1, p.z, bridgeGroup, {x:0.2,y:0.4,z:0.2}, 1);
                }
            }
        }
        makeBridge(biomes.campfire.position, biomes.forest.position);
        makeBridge(biomes.campfire.position, biomes.lava.position);
        makeBridge(biomes.campfire.position, biomes.citadel.position);
    }

    initWorld();
    buildBridges();

    // 6. Environment
    const cloudParticles = [];
    function createClouds() {
        const cloudGeo = new THREE.IcosahedronGeometry(1, 0);
        const cloudMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, flatShading: true });
        const ocean = new THREE.InstancedMesh(cloudGeo, cloudMat, 300);
        const dummy = new THREE.Object3D();
        for(let i=0; i<300; i++) {
            dummy.position.set((Math.random()-0.5)*200, -25 + Math.random()*5, (Math.random()-0.5)*150);
            const s = 4 + Math.random()*6;
            dummy.scale.set(s*1.5, s*0.8, s);
            dummy.updateMatrix();
            ocean.setMatrixAt(i, dummy.matrix);
        }
        scene.add(ocean);
        for(let i=0; i<30; i++) {
            const c = new THREE.Mesh(cloudGeo, cloudMat);
            c.position.set((Math.random()-0.5)*100, Math.random()*15 - 5, (Math.random()-0.5)*80);
            c.scale.setScalar(2 + Math.random());
            c.userData.speed = 0.02 + Math.random()*0.02;
            scene.add(c);
            cloudParticles.push(c);
        }
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<1000; i++) {
            starPos.push((Math.random()-0.5)*400, (Math.random()-0.5)*200 + 50, (Math.random()-0.5)*400);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.5, transparent: true, opacity: 0.6});
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);
        scene.userData.stars = stars;
    }
    createClouds();

    /* =========================================
       BOSS: THE SKY KRAKEN
       ========================================= */
    const bossGroup = new THREE.Group();
    scene.add(bossGroup);
    bossGroup.visible = false;

    function buildBoss() {
        const cloudGroup = new THREE.Group();
        for(let i=0; i<20; i++) {
            const p = createVoxel(0x8899aa, (Math.random()-0.5)*8, (Math.random()-0.5)*2, (Math.random()-0.5)*8, cloudGroup, 
                {x:2+Math.random()*2, y:1+Math.random(), z:2+Math.random()*2});
            p.material.transparent = true;
            p.material.opacity = 0.6;
        }
        bossGroup.add(cloudGroup);
        state.bossParts.push({mesh: cloudGroup, type: 'cloud', rot: {x:0, y:0.005}});
        const head = new THREE.Group();
        head.position.y = 4;
        createVoxel(0x4b0082, 0, 2, 0, head, {x:4, y:5, z:4}); 
        createVoxel(0x4b0082, 0, 5, 0, head, {x:3, y:2, z:3}); 
        createEmissiveVoxel(0x00ffcc, 1.2, 1, 1.8, head, {x:0.8, y:0.8, z:0.5}, 5);
        createEmissiveVoxel(0x00ffcc, -1.2, 1, 1.8, head, {x:0.8, y:0.8, z:0.5}, 5);
        bossGroup.add(head);
        state.bossParts.push({mesh: head, type: 'head', rot: {x:0, y:0}});
        const tentacleCount = 8;
        for(let i=0; i<tentacleCount; i++) {
            const angle = (i/tentacleCount) * Math.PI * 2;
            const tGroup = new THREE.Group();
            tGroup.position.set(Math.cos(angle)*2, 4, Math.sin(angle)*2);
            tGroup.rotation.y = -angle;
            for(let j=0; j<6; j++) {
                const seg = createVoxel(0x5e2a84, 0, -j*1.2, 0, tGroup, {x:0.8 - j*0.1, y:1, z:0.8 - j*0.1});
                if(j<5) createEmissiveVoxel(0xff00ff, 0, -j*1.2, 0.4, tGroup, {x:0.2, y:0.2, z:0.1}, 0.5);
            }
            bossGroup.add(tGroup);
            state.bossParts.push({mesh: tGroup, type: 'tentacle', index: i});
        }
    }
    buildBoss();

    setTimeout(() => {
        document.getElementById('loader').style.opacity = 0;
        setTimeout(() => document.getElementById('loader').style.display='none', 1000);
        renderTasks();
    }, 1500);

    /* =========================================
       ANIMATION LOOP
       ========================================= */
    const clock = new THREE.Clock();
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -5); 

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        if(!state.isBattling) {
            worldGroup.rotation.y = Math.sin(time * 0.05) * 0.05;
        }

        if(state.view === 'map') {
            const targetX = mouse.x * 5; 
            const targetY = 50 + (mouse.y * 5); 
            camera.position.x += (targetX - camera.position.x) * 0.05;
            camera.position.y += (targetY - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);
        }

        raycaster.setFromCamera(mouse, camera);
        const target = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, target);
        if(target) {
            cursorLight.position.x += (target.x - cursorLight.position.x) * 0.1;
            cursorLight.position.z += (target.z - cursorLight.position.z) * 0.1;
            cursorLight.position.y = 15 + Math.sin(time) * 2; 
        }

        if(scene.userData.stars) scene.userData.stars.rotation.y = time * 0.005;

        biomes.citadel.position.y = 6 + Math.sin(time*0.5)*0.5;
        biomes.campfire.position.y = -2 + Math.sin(time*0.3)*0.3;
        if(biomes.citadel.userData.wallRing) {
            biomes.citadel.userData.wallRing.rotation.y = time * 0.1;
            biomes.citadel.userData.wallRing.position.y = Math.sin(time) * 0.5;
        }

        if(biomes.campfire.userData.fireLight) {
            const noise = Math.sin(time * 20) + Math.sin(time * 50) * 0.5;
            biomes.campfire.userData.fireLight.intensity = 2 + noise * 0.5;
            state.fireParticles.forEach(p => {
                p.userData.life -= 0.02;
                if(p.userData.life <= 0) resetParticle(p);
                p.position.y += p.userData.speedY;
                p.position.x += p.userData.drift + Math.sin(time * 5 + p.position.y)*0.005;
                p.position.z += p.userData.drift + Math.cos(time * 3 + p.position.y)*0.005;
                const life = p.userData.life;
                p.scale.setScalar(life * 0.3); 
                if(life > 0.7) p.material.color.setHex(0xffff00); 
                else if (life > 0.4) p.material.color.setHex(0xffaa00); 
                else if (life > 0.2) p.material.color.setHex(0xff0000); 
                else { p.material.color.setHex(0x555555); p.material.emissiveIntensity = 0; }
            });
        }

        if(state.lavaHeart) {
            const pulse = 1 + Math.sin(time * 10) * 0.1; 
            state.lavaHeart.core.scale.set(pulse, pulse, pulse);
            state.lavaHeart.light.intensity = 2 + Math.random();
            state.lavaHeart.group.rotation.y = time * 0.5;
        }

        cloudParticles.forEach(c => {
            c.position.x += c.userData.speed;
            if(c.position.x > 80) c.position.x = -80;
        });

        const particles = [biomes.forest.userData.particles].flat();
        particles.forEach(p => {
            if(!p) return;
            const pos = p.geometry.attributes.position.array;
            for(let i=1; i<pos.length; i+=3) {
                pos[i] += Math.sin(time + pos[i-1])*0.02; 
            }
            p.geometry.attributes.position.needsUpdate = true;
        });

        if(state.isBattling) {
            bossGroup.position.y = 10 + Math.sin(time * 0.5) * 2;
            state.bossParts.forEach(p => {
                if(p.type === 'cloud') {
                    p.mesh.rotation.y += p.rot.y;
                    p.mesh.children.forEach((c, idx) => {
                         c.position.y += Math.sin(time * 2 + idx) * 0.01;
                    });
                }
                if(p.type === 'head') {
                    p.mesh.rotation.y = Math.sin(time * 0.5) * 0.1;
                }
                if(p.type === 'tentacle') {
                    p.mesh.rotation.z = Math.sin(time * 2 + p.index) * 0.1;
                    p.mesh.children.forEach((seg, idx) => {
                        seg.position.x = Math.sin(time * 3 + p.index + idx) * 0.1;
                    });
                }
            });
        }

        state.mobs.forEach(mob => {
            const type = mob.userData.type;
            
            if(type === 'rabbit') {
                mob.userData.timer -= delta;
                if(mob.userData.timer <= 0) {
                    if(mob.userData.state === 'idle') {
                        mob.userData.state = 'jump';
                        mob.userData.timer = 0.5;
                        mob.userData.jumpTarget.set((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2);
                        mob.rotation.y = Math.atan2(mob.userData.jumpTarget.x, mob.userData.jumpTarget.z);
                    } else {
                        mob.userData.state = 'idle';
                        mob.userData.timer = 1 + Math.random() * 2;
                        mob.position.y = mob.userData.baseY;
                    }
                }
                if(mob.userData.state === 'jump') {
                    const progress = 1 - (mob.userData.timer / 0.5);
                    mob.position.y = mob.userData.baseY + Math.sin(progress * Math.PI) * 0.8;
                    const nextX = mob.position.x + mob.userData.jumpTarget.x * 0.02;
                    const nextZ = mob.position.z + mob.userData.jumpTarget.z * 0.02;
                    if(nextX*nextX + nextZ*nextZ < 49) {
                        mob.position.x = nextX;
                        mob.position.z = nextZ;
                    } else {
                        mob.userData.jumpTarget.multiplyScalar(-1);
                    }
                }
            } 
            else if(type === 'slime') {
                mob.userData.timer -= delta;
                if(mob.userData.timer <= 0) {
                    if(mob.userData.state === 'idle') {
                        mob.userData.state = 'jump';
                        mob.userData.timer = 0.8; 
                        const angle = Math.random() * Math.PI * 2; 
                        mob.userData.jumpTarget = new THREE.Vector3(Math.cos(angle)*2, 0, Math.sin(angle)*2);
                        mob.rotation.y = Math.atan2(mob.userData.jumpTarget.x, mob.userData.jumpTarget.z);
                    } else {
                        mob.userData.state = 'idle';
                        mob.userData.timer = 1 + Math.random();
                        mob.position.y = mob.userData.baseY;
                    }
                }
                
                if(mob.userData.state === 'jump') {
                    const progress = 1 - (mob.userData.timer / 0.8);
                    mob.position.y = mob.userData.baseY + (4 * 1.5 * progress * (1 - progress));
                    const speed = 0.03;
                    const nextX = mob.position.x + mob.userData.jumpTarget.x * speed;
                    const nextZ = mob.position.z + mob.userData.jumpTarget.z * speed;
                    if(nextX*nextX + nextZ*nextZ < 49) {
                         mob.position.x = nextX;
                         mob.position.z = nextZ;
                    }
                }
            }
            else if(type === 'hulk') {
                mob.userData.timer -= delta;
                if(mob.userData.timer <= 0) {
                   const angle = Math.random() * Math.PI * 2;
                   mob.userData.dir.set(Math.cos(angle)*0.02, 0, Math.sin(angle)*0.02);
                   mob.rotation.y = Math.atan2(mob.userData.dir.x, mob.userData.dir.z);
                   mob.userData.timer = 2 + Math.random();
                }
                const nextX = mob.position.x + mob.userData.dir.x;
                const nextZ = mob.position.z + mob.userData.dir.z;
                if(nextX*nextX + nextZ*nextZ < 40) {
                    mob.position.add(mob.userData.dir);
                    if(mob.userData.chain && Math.random() > 0.7) {
                        const spark = createEmissiveVoxel(0xffaa00, 
                            mob.position.x + (Math.random()-0.5), 
                            0.5, 
                            mob.position.z + (Math.random()-0.5), 
                            biomes.lava, 
                            {x:0.1, y:0.1, z:0.1}, 2
                        );
                        gsap.to(spark.position, {y:1.5, x:spark.position.x+(Math.random()-0.5), duration:0.5});
                        gsap.to(spark.scale, {x:0, y:0, z:0, duration:0.5, onComplete:()=>biomes.lava.remove(spark)});
                    }
                } else {
                    mob.userData.dir.multiplyScalar(-1);
                    mob.rotation.y = Math.atan2(mob.userData.dir.x, mob.userData.dir.z);
                }
            }
            else if(type === 'wizard') {
                mob.userData.timer -= delta;
                if(mob.userData.timer <= 0) {
                    const angle = Math.random() * Math.PI * 2;
                    mob.userData.dir.set(Math.cos(angle)*0.015, 0, Math.sin(angle)*0.015);
                    mob.userData.timer = 2 + Math.random() * 3;
                }
                const nextX = mob.position.x + mob.userData.dir.x;
                const nextZ = mob.position.z + mob.userData.dir.z;
                const inCourtyard = (Math.abs(nextX) < 4 && nextZ > -1 && nextZ < 5);
                if(inCourtyard) {
                    mob.position.add(mob.userData.dir);
                    mob.lookAt(mob.position.x + mob.userData.dir.x * 5, mob.position.y, mob.position.z + mob.userData.dir.z * 5);
                } else {
                    mob.userData.dir.multiplyScalar(-1); 
                }
                const bob = Math.sin(time * 2 + mob.userData.hoverOffset) * 0.2;
                mob.position.y = mob.userData.baseY + bob;
                if(mob.userData.book) {
                    mob.userData.book.position.y = 1.1 + Math.sin(time * 3) * 0.05;
                    mob.userData.book.rotation.y = Math.sin(time) * 0.1;
                }
            }
        });

        renderer.render(scene, camera);
    }
    animate();

    const VIEWS = {
        map: { pos: {x:0, y:50, z:70}, look: {x:0, y:0, z:0} },
        forest: { pos: {x:-20, y:20, z:35}, look: {x:-20, y:0, z:5} },
        lava: { pos: {x:20, y:20, z:35}, look: {x:20, y:-2, z:5} },
        citadel: { pos: {x:0, y:25, z:20}, look: {x:0, y:6, z:-15} }, 
        campfire: { pos: {x:0, y:12, z:20}, look: {x:0, y:0, z:5} },
        battle: { pos: {x:0, y:15, z:55}, look: {x:0, y:10, z:0} } 
    };

    function switchView(viewName) {
        state.view = viewName;
        const target = VIEWS[viewName];
        
        gsap.to(worldGroup.rotation, {y: 0, duration: 1});

        gsap.to(camera.position, {
            x: target.pos.x, y: target.pos.y, z: target.pos.z,
            duration: 1.5, ease: "power2.inOut"
        });
        
        const temp = { x: state.lastLook?.x||0, y: state.lastLook?.y||0, z: state.lastLook?.z||0 };
        gsap.to(temp, {
            x: target.look.x, y: target.look.y, z: target.look.z,
            duration: 1.5, ease: "power2.inOut",
            onUpdate: () => camera.lookAt(temp.x, temp.y, temp.z),
            onComplete: () => state.lastLook = target.look
        });

        const isMap = viewName === 'map';
        document.getElementById('back-btn').style.display = isMap ? 'none' : 'block';
        document.getElementById('action-btn').style.display = isMap ? 'block' : 'none';
        
        const scroll = document.getElementById('scroll-container');
        if(!isMap) {
            scroll.classList.add('minimized');
            document.getElementById('toggle-scroll-btn').style.display = 'none';
        } else {
            document.getElementById('toggle-scroll-btn').style.display = 'flex';
            scroll.classList.remove('minimized');
        }

        if(viewName === 'campfire') {
            scroll.classList.remove('minimized');
            document.getElementById('scroll-title').innerText = "Game Guide";
            document.getElementById('task-list').innerHTML = `
                <div style="padding:15px; font-size:14px; line-height:1.6; text-align:left;">
                    <strong><i class="fas fa-exclamation-circle"></i> Instructions:</strong><br><br>
                    1. <strong>Tasks = Ammunition:</strong> Completing tasks in the scroll grants you charges for the final battle.<br>
                    2. <strong>More Tasks, Higher Chance:</strong> The more prepared you are, the higher your chance of defeating the Sky Kraken.<br>
                    3. <strong>Zero Tolerance:</strong> Entering the battle with 0 tasks completed results in <span style="color:red; font-weight:bold;">IMMEDIATE DEFEAT</span> and map destruction.<br><br>
                    Prepare wisely, traveler.
                </div>
            `;
            document.querySelector('.scroll-body > div:last-child').style.display = 'none';
        } else {
            document.getElementById('scroll-title').innerText = "Captain's Log";
            document.querySelector('.scroll-body > div:last-child').style.display = 'block';
            if(isMap) renderTasks(); 
        }

        if(!isMap && viewName !== 'battle') {
            const data = BIOME_DATA[viewName];
            const label = document.getElementById('biome-name');
            label.innerText = data.name;
            label.style.fontFamily = data.font;
            label.style.color = data.titleColor;
            label.style.textShadow = `0 0 20px ${data.titleColor}`;
            document.getElementById('biome-desc').innerText = data.desc;
            document.getElementById('biome-label').style.opacity = 1;
        } else {
            document.getElementById('biome-label').style.opacity = 0;
        }
    }
    
    window.addEventListener('mousemove', (e) => {
        mouse.x = (e.clientX/window.innerWidth)*2-1;
        mouse.y = -(e.clientY/window.innerHeight)*2+1;

        if(state.view !== 'map') return;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(worldGroup.children, true);
        
        if(intersects.length > 0) {
            let obj = intersects[0].object;
            while(obj.parent && obj.parent !== worldGroup) obj = obj.parent;
            
            if(obj.userData.id && state.highlightedBiome !== obj) {
                if(state.highlightedBiome) removeHighlight(state.highlightedBiome);
                state.highlightedBiome = obj;
                addHighlight(obj);
                document.body.style.cursor = 'pointer';
            }
        } else {
            if(state.highlightedBiome) {
                removeHighlight(state.highlightedBiome);
                state.highlightedBiome = null;
                document.body.style.cursor = 'default';
            }
        }
    });

    document.addEventListener('keydown', (e) => {
        if(e.key === "Escape" && state.view !== 'map' && !state.isBattling) {
            returnToMap();
        }
    });

    function addHighlight(group) {
        gsap.to(group.position, { y: group.userData.baseY + 1.5, duration: 0.4, ease: "power2.out" });
        gsap.to(group.scale, { x: 1.05, z: 1.05, duration: 0.4 });
        gsap.to(cursorLight, { intensity: 2.5, distance: 30, duration: 0.2 });
    }
    function removeHighlight(group) {
        gsap.to(group.position, { y: group.userData.baseY, duration: 0.4, ease: "power2.out" });
        gsap.to(group.scale, { x: 1, z: 1, duration: 0.4 });
        gsap.to(cursorLight, { intensity: 1.5, distance: 20, duration: 0.2 });
    }

    window.addEventListener('click', (e) => {
        if(e.target.closest('.glass-panel') || e.target.closest('button') || e.target.closest('#scroll-container') || e.target.closest('#toggle-scroll-btn')) return;
        if(state.view === 'map' && !state.isBattling && state.highlightedBiome) {
            switchView(state.highlightedBiome.userData.id);
        }
    });

    window.returnToMap = () => {
        if(state.view === 'campfire') renderTasks();
        switchView('map');
    };

    /* =========================================
       UI LOGIC
       ========================================= */
    function renderTasks() {
        const list = document.getElementById('task-list');
        list.innerHTML = '';
        state.tasks.forEach((t, i) => {
            const biomeEntry = Object.values(BIOME_DATA).find(b => b.stat === t.type);
            const colorNum = biomeEntry ? biomeEntry.color : 0x5c4a3b;
            const colorHex = '#' + colorNum.toString(16).padStart(6, '0');
            const r = (colorNum >> 16) & 255;
            const g = (colorNum >> 8) & 255;
            const b = colorNum & 255;
            const bgStart = `rgba(${r}, ${g}, ${b}, 0.1)`;
            const bgEnd = `rgba(${r}, ${g}, ${b}, 0.05)`;

            const div = document.createElement('div');
            div.className = `task-item ${t.completed?'completed':''}`;
            div.style.borderLeft = `4px solid ${colorHex}`;
            div.style.background = `linear-gradient(to right, ${bgStart}, ${bgEnd})`;
            let icon = 'fa-scroll';
            if(t.type === 'courage') icon = 'fa-tree';
            if(t.type === 'strength') icon = 'fa-fire';
            if(t.type === 'intellect') icon = 'fa-cube';
            if(t.type === 'campfire') icon = 'fa-campground';

            div.innerHTML = `
                <div style="display:flex; align-items:center; gap:10px;">
                    <div style="width: 24px; height: 24px; background: ${colorHex}; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                        <i class="fas ${icon}"></i>
                    </div>
                    <div style="font-weight:bold; color: var(--ink);">${t.text}</div>
                </div>
                <div style="font-family:'Homemade Apple'; font-size:12px; color: ${colorHex}; font-weight: bold;">${t.completed ? 'Done' : 'Pending'}</div>
            `;
            div.onclick = () => toggleTask(i);
            list.appendChild(div);
        });
        updateStats();
    }

    function updateStats() {
        ['courage', 'strength', 'intellect'].forEach(stat => {
            const all = state.tasks.filter(t => t.type === stat);
            const done = all.filter(t => t.completed).length;
            const pct = all.length ? (done / all.length) * 100 : 0;
            document.getElementById(`val-${stat}`).innerText = `${done}/${all.length}`;
            document.getElementById(`bar-${stat}`).style.width = `${pct}%`;
        });
    }

    window.addTask = () => {
        const input = document.getElementById('task-input');
        const type = document.getElementById('task-type').value;
        if(input.value.trim()) {
            state.tasks.push({ text: input.value, type, completed: false });
            input.value = '';
            renderTasks();
        }
    };
    
    document.getElementById('task-input').addEventListener('keypress', (e) => {
        if(e.key === 'Enter') addTask();
    });

    window.toggleScroll = () => {
        const scroll = document.getElementById('scroll-container');
        scroll.classList.toggle('minimized');
    };

    function toggleTask(i) {
        state.tasks[i].completed = !state.tasks[i].completed; 
        renderTasks();
        if(state.tasks[i].completed) {
            const type = state.tasks[i].type;
            if(biomes[type]) pulseBiome(biomes[type]);
        }
    }

    function pulseBiome(group) {
        const beam = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 30, 8),
            new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0 })
        );
        beam.position.copy(group.position);
        beam.position.y += 10;
        scene.add(beam);
        gsap.to(beam.material, { opacity: 0.8, duration: 0.2, yoyo: true, repeat: 1 });
        gsap.to(beam.scale, { x: 5, z: 5, duration: 0.5, onComplete: () => scene.remove(beam) });
    }

    /* =========================================
       BATTLE SYSTEM
       ========================================= */
    function updateBattleUI() {
        ['courage', 'strength', 'intellect'].forEach(type => {
            const count = state.ammo[type];
            const btn = document.getElementById(`btn-${type}`);
            const span = document.getElementById(`ammo-${type}`);
            span.innerText = `[${count}]`;
            
            if(count <= 0) {
                btn.setAttribute('disabled', 'true');
                btn.style.opacity = 0.5;
                btn.style.cursor = 'not-allowed';
            } else {
                btn.removeAttribute('disabled');
                btn.style.opacity = 1;
                btn.style.cursor = 'pointer';
            }
        });
    }

    // --- DESTRUCTION SEQUENCE ---
    function triggerWorldDestruction() {
        // 1. Violent Camera Shake
        gsap.to(camera.position, {
            x: "+=2", y: "+=2", z: "+=2",
            duration: 0.05, repeat: 30, yoyo: true
        });

        // 2. Mobs Fly Into Void
        state.mobs.forEach(mob => {
            gsap.to(mob.position, {
                y: -150,
                x: mob.position.x + (Math.random()-0.5)*50,
                z: mob.position.z + (Math.random()-0.5)*50,
                rotationX: Math.random()*10,
                rotationZ: Math.random()*10,
                duration: 3,
                ease: "power2.in"
            });
        });

        // 3. Shatter Biomes (Simulated)
        // We iterate through biome groups and make random children fall
        [biomes.forest, biomes.lava, biomes.citadel, biomes.campfire].forEach(group => {
            shatterBiome(group);
        });

        // Boss looks triumphant
        gsap.to(bossGroup.scale, {x:1.5, y:1.5, z:1.5, duration:0.5, yoyo:true, repeat:5});
    }

    function shatterBiome(group) {
        group.children.forEach(child => {
            if(Math.random() > 0.3) { // 70% of the map breaks
                gsap.to(child.position, {
                    y: -200,
                    x: child.position.x + (Math.random()-0.5)*20,
                    z: child.position.z + (Math.random()-0.5)*20,
                    duration: 2 + Math.random()*3,
                    ease: "power2.in",
                    delay: Math.random()
                });
                gsap.to(child.rotation, {
                    x: Math.random()*5,
                    z: Math.random()*5,
                    duration: 3
                });
            }
        });
    }

    window.initiateBattle = () => {
        // CHECK: Any tasks completed?
        const totalCompleted = state.tasks.filter(t => t.completed).length;
        
        state.isBattling = true;
        
        // Setup visuals
        document.getElementById('curtain-left').classList.add('closed');
        document.getElementById('curtain-right').classList.add('closed');
        document.getElementById('ui-layer').classList.add('hidden');
        document.getElementById('action-btn').style.display = 'none';
        document.getElementById('scroll-container').classList.add('minimized');
        document.getElementById('toggle-scroll-btn').style.display = 'none';
        document.body.classList.add('storm-mode');

        if(totalCompleted === 0) {
            // INSTANT DEFEAT PATH
            setTimeout(() => {
                switchView('battle');
                bossGroup.visible = true;
                document.getElementById('curtain-left').classList.remove('closed');
                document.getElementById('curtain-right').classList.remove('closed');
                
                // Wait briefly then DESTROY
                setTimeout(() => {
                    triggerWorldDestruction();
                    // Show Defeat Modal
                    setTimeout(() => showModal(false, 0), 3000);
                }, 1000);
            }, 2200);
            return;
        }

        // NORMAL BATTLE PATH
        state.ammo.courage = state.tasks.filter(t => t.type === 'courage' && t.completed).length;
        state.ammo.strength = state.tasks.filter(t => t.type === 'strength' && t.completed).length;
        state.ammo.intellect = state.tasks.filter(t => t.type === 'intellect' && t.completed).length;
        updateBattleUI();

        setTimeout(() => {
            switchView('battle');
            bossGroup.visible = true;
            const stormColor = new THREE.Color(CONFIG.colors.stormBottom);
            scene.fog.color.copy(stormColor);
            hemiLight.intensity = 0.2;
            cursorLight.intensity = 0; 
            
            document.getElementById('curtain-left').classList.remove('closed');
            document.getElementById('curtain-right').classList.remove('closed');
            
            const battleMsg = document.getElementById('battle-msg');
            const battleControls = document.getElementById('battle-controls');
            const battleUI = document.getElementById('battle-ui');
            
            battleUI.style.display = 'flex';
            battleMsg.innerText = "The Sky Kraken Rises...";
            gsap.to(battleMsg, { opacity: 1, y: 0, duration: 1, delay: 1 });
            gsap.to(battleControls, { opacity: 1, y: 0, duration: 1, delay: 1.5 });
        }, 2200); 
    };

    function fireProjectile(targetPos, color) {
        const proj = createEmissiveVoxel(color, 
            camera.position.x, camera.position.y - 2, camera.position.z - 2, 
            scene, {x:0.5, y:0.5, z:0.5}, 5
        );
        
        gsap.to(proj.position, {
            x: targetPos.x, y: targetPos.y + 4, z: targetPos.z, 
            duration: 0.6, 
            ease: "power1.in",
            onComplete: () => {
                scene.remove(proj);
                const impact = createEmissiveVoxel(color, targetPos.x, targetPos.y+4, targetPos.z, scene, {x:3,y:3,z:3}, 10);
                gsap.to(impact.scale, {x:6, y:6, z:6, duration:0.2, onComplete:()=>scene.remove(impact)});
                gsap.to(impact.material, {opacity:0, duration:0.2});
                
                gsap.to(bossGroup.position, {z:"-=2", duration:0.1, yoyo:true, repeat:1});
                bossGroup.children.forEach(c => {
                    if(c.isGroup && c.children[0].material) {
                        const old = c.children[0].material.color.getHex();
                        c.children.forEach(m=>m.material.color.setHex(color));
                        setTimeout(()=>c.children.forEach(m=>m.material.color.setHex(old)), 100);
                    }
                });
            }
        });
    }

    window.performAttack = (type) => {
        if(state.ammo[type] <= 0) return;

        state.ammo[type]--;
        updateBattleUI();

        const battleMsg = document.getElementById('battle-msg');
        battleMsg.innerText = `Casting ${type.toUpperCase()}...`;
        
        gsap.to(camera.position, {y:"+=0.5", duration:0.1, yoyo:true, repeat:1});
        
        let col = 0xffffff;
        if(type === 'courage') col = CONFIG.colors.forest;
        if(type === 'strength') col = CONFIG.colors.lava;
        if(type === 'intellect') col = CONFIG.colors.citadel;

        fireProjectile(bossGroup.position, col);

        const totalAmmo = state.ammo.courage + state.ammo.strength + state.ammo.intellect;
        
        if(totalAmmo <= 0) {
            setTimeout(calculateResult, 1500);
        }
    };

    function calculateResult() {
        const relevantTasks = state.tasks.filter(t => t.type !== 'campfire'); 
        const total = relevantTasks.length;
        const completed = relevantTasks.filter(t => t.completed).length;
        let pct = total > 0 ? completed / total : 0;
        
        // --- SOFT GACHA LOGIC ---
        // Base win chance reduced to 5% as requested.
        const baseWinChance = 0.05; 
        const winChance = baseWinChance + (pct * (1 - baseWinChance));

        const roll = Math.random();
        const victory = roll < winChance;

        if(victory) {
            gsap.to(bossGroup.scale, { x:0, y:0, z:0, duration: 1, ease:"back.in" });
            setTimeout(() => showModal(true, pct), 1500);
        } else {
            // Defeat -> Destruction
            triggerWorldDestruction();
            document.body.style.backgroundColor = "#500000";
            setTimeout(() => document.body.style.backgroundColor = "", 200);
            setTimeout(() => showModal(false, pct), 3000);
        }
    }
    
    function showModal(victory, pct) {
        document.getElementById('battle-ui').style.display = 'none';
        const modal = document.getElementById('modal-overlay');
        const title = document.getElementById('modal-title');
        const msg = document.getElementById('modal-msg');
        modal.style.display = 'flex';
        
        if(victory) {
            title.innerText = "Storm Cleared";
            const messages = [
                "The darkness recedes. You are stronger now.",
                "Discipline has prevailed.",
                "The world breathes easier today."
            ];
            msg.innerText = messages[Math.floor(Math.random()*messages.length)];
        } else {
            title.innerText = "Kingdom Fallen";
            msg.innerText = "The Sky Kraken has shattered the realm. The void claims all.";
        }
    }

    window.closeModal = () => {
        document.getElementById('modal-overlay').style.display = 'none';
        document.body.classList.remove('storm-mode');
        const skyColor = new THREE.Color(CONFIG.colors.skyBottom);
        gsap.to(scene.fog.color, { r: skyColor.r, g: skyColor.g, b: skyColor.b, duration: 2 });
        hemiLight.intensity = 0.9;
        cursorLight.intensity = 1.5;

        bossGroup.visible = false;
        bossGroup.scale.set(1,1,1); 
        
        // RESET THE WORLD (Rebuild logic)
        initWorld();

        state.isBattling = false;
        document.getElementById('ui-layer').classList.remove('hidden');
        document.getElementById('toggle-scroll-btn').style.display = 'flex';
        document.getElementById('scroll-container').classList.remove('minimized');
        switchView('map');
    };

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
