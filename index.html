<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Kingdom: Ascension</title>
    <!-- Fonts: Cinzel for Titles, Lato for UI -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Lato:wght@400;700&family=Homemade+Apple&family=Orbitron:wght@500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            /* Sky Kingdom Palette */
            --sky-top: #6dd5fa;
            --sky-bottom: #b2fefa;
            --storm-top: #0f172a;
            --storm-bottom: #1e293b;
            
            --glass-bg: rgba(255, 255, 255, 0.2);
            --glass-border: rgba(255, 255, 255, 0.4);
            --text-dark: #1e293b;
            --text-light: #f8fafc;
            
            /* Stat Colors */
            --courage: #4ade80;  /* Forest */
            --strength: #f87171; /* Lava */
            --intellect: #60a5fa; /* Citadel */

            /* Scroll Palette */
            --parchment: #fdf6e3;
            --ink: #2c1a0b;
            --ink-light: #5c4a3b;
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, var(--sky-top), var(--sky-bottom));
            font-family: 'Lato', sans-serif;
            color: var(--text-dark);
            transition: background 2s ease;
        }

        body.storm-mode {
            background: linear-gradient(to bottom, var(--storm-top), var(--storm-bottom));
            color: var(--text-light);
        }

        #canvas-container {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            z-index: 1;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            padding: 24px;
            display: flex; flex-direction: column; justify-content: space-between;
            transition: opacity 0.5s;
        }
        
        #ui-layer.hidden { opacity: 0; pointer-events: none; }

        /* Glass Panel (Top Stats) */
        .glass-panel {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 15px 25px;
            pointer-events: auto;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .glass-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(31, 38, 135, 0.2);
            border-color: rgba(255,255,255,0.6);
        }

        h1, h2, h3, .fantasy-font {
            font-family: 'Cinzel', serif;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 0;
        }

        /* Top Stats Bar */
        #top-bar {
            display: flex; gap: 30px; align-self: center;
            background: rgba(255,255,255,0.25);
            border-radius: 50px;
        }

        .stat-badge {
            display: flex; flex-direction: column; align-items: flex-start;
            min-width: 140px;
        }
        
        .stat-header {
            display: flex; justify-content: space-between; width: 100%;
            font-size: 11px; font-weight: 700; margin-bottom: 6px; letter-spacing: 1px;
        }
        
        .stat-bar-container {
            width: 100%; height: 8px; background: rgba(0,0,0,0.2);
            border-radius: 4px; overflow: hidden;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .stat-fill { 
            height: 100%; width: 0%; 
            transition: width 0.8s cubic-bezier(0.34, 1.56, 0.64, 1); 
            box-shadow: 0 0 10px currentColor;
        }

        /* --- PIRATE SCROLL (Task Panel) --- */
        #scroll-container {
            position: absolute; right: 30px; top: 100px;
            width: 360px;
            pointer-events: auto;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            transform-origin: top right;
            z-index: 50;
        }

        #scroll-container.minimized {
            transform: scale(0.0) translate(200px, -200px);
            opacity: 0; pointer-events: none;
        }

        .scroll-body {
            background: var(--parchment);
            color: var(--ink);
            padding: 40px 30px;
            border-radius: 4px;
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.3),
                inset 0 0 60px rgba(160, 130, 80, 0.2);
            position: relative;
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.5' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100' height='100' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
        }

        /* Top and Bottom Rollers */
        .scroll-body::before, .scroll-body::after {
            content: ''; position: absolute; left: -10px; right: -10px; height: 20px;
            background: #e3d2a8;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4), inset 0 2px 5px rgba(255,255,255,0.4);
            z-index: 2;
        }
        .scroll-body::before { top: -10px; }
        .scroll-body::after { bottom: -10px; }

        .scroll-header {
            text-align: center; border-bottom: 2px solid var(--ink-light);
            padding-bottom: 10px; margin-bottom: 15px;
        }
        .scroll-header h2 { font-size: 24px; color: var(--ink); text-shadow: none; }
        .scroll-date { font-family: 'Homemade Apple', cursive; color: var(--ink-light); font-size: 14px; margin-top: 5px; }

        #task-list {
            max-height: 300px; overflow-y: auto; padding-right: 5px; margin-bottom: 20px;
        }
        
        #task-list::-webkit-scrollbar { width: 6px; }
        #task-list::-webkit-scrollbar-thumb { background: var(--ink-light); border-radius: 3px; }
        
        .task-item {
            font-family: 'Lato', sans-serif;
            background: rgba(255,255,255,0.4);
            padding: 10px; margin-bottom: 8px; 
            border-bottom: 1px dashed var(--ink-light);
            display: flex; align-items: center; justify-content: space-between;
            cursor: pointer; transition: all 0.2s;
            color: var(--ink);
            position: relative;
            overflow: hidden;
        }
        .task-item:hover { 
            transform: translateX(4px); 
            background: rgba(255,255,255,0.7); 
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .task-item.completed { opacity: 0.5; text-decoration: line-through; background: rgba(255,255,255,0.2); }

        /* Minimize Button */
        #toggle-scroll-btn {
            position: absolute; top: 100px; right: 30px;
            width: 45px; height: 45px;
            background: var(--parchment);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            cursor: pointer; z-index: 60; pointer-events: auto;
            border: 2px solid #e3d2a8;
            font-size: 18px; color: var(--ink);
            transition: all 0.3s;
        }
        #toggle-scroll-btn:hover { transform: scale(1.1); }
        
        /* Styled Inputs */
        input.scroll-input {
            background: transparent; border: none; border-bottom: 2px solid var(--ink-light);
            font-family: 'Lato', sans-serif;
            font-weight: bold;
            color: var(--ink);
            font-size: 14px; padding: 5px; width: 100%; outline: none;
        }
        
        /* Custom Select Styling */
        .select-wrapper {
            position: relative;
            width: 70%;
        }
        select.scroll-input {
            width: 100%;
            appearance: none;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.3); 
            border: none; 
            border-bottom: 2px solid var(--ink-light);
            font-family: 'Lato', sans-serif;
            color: var(--ink);
            font-size: 12px; padding: 5px; outline: none;
            cursor: pointer;
        }
        /* Custom arrow for select */
        .select-wrapper::after {
            content: 'â–¼';
            font-size: 10px;
            color: var(--ink-light);
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
        }

        input.scroll-input::placeholder { color: rgba(44, 26, 11, 0.4); font-style: italic; }
        
        button.scroll-btn {
            background: var(--ink); color: var(--parchment);
            border: none; padding: 8px 16px; border-radius: 4px;
            font-family: 'Cinzel'; cursor: pointer;
            transition: transform 0.1s; margin-left: 5px;
            flex-grow: 1;
        }
        button.scroll-btn:hover { transform: scale(1.05); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }

        /* Controls & Navigation */
        #biome-label {
            position: absolute; bottom: 40px; left: 40px; 
            text-align: left; pointer-events: none; opacity: 0; transition: opacity 0.5s;
            z-index: 20;
        }
        #biome-label h1 {
            font-size: 64px; margin: 0; line-height: 1;
            /* Updated to use glow instead of outline for readability */
            text-shadow: 0 0 25px currentColor, 0 0 10px black;
        }
        #biome-desc {
            color: white; 
            letter-spacing: 4px; 
            text-transform: uppercase; 
            font-size: 14px; 
            opacity: 0.9;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
        }

        #back-btn {
            position: fixed; top: 24px; left: 24px;
            z-index: 100; display: none; pointer-events: auto;
            background: rgba(255, 255, 255, 0.9); border-radius: 30px;
            padding: 12px 30px; border: none; font-weight: bold; cursor: pointer;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            font-family: 'Cinzel'; transition: all 0.2s;
            color: var(--text-dark);
            border: 1px solid rgba(0,0,0,0.1);
        }
        #back-btn:hover { transform: scale(1.05); box-shadow: 0 8px 25px rgba(0,0,0,0.15); }

        #action-btn {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            padding: 20px 60px; font-size: 20px; border-radius: 50px;
            background: linear-gradient(135deg, #FF9966 0%, #FF5E62 100%);
            border: 2px solid rgba(255,255,255,0.5);
            color: white; box-shadow: 0 10px 40px rgba(255, 94, 98, 0.5);
            pointer-events: auto; transition: all 0.3s;
            overflow: hidden;
            text-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 80;
        }
        #action-btn:hover { transform: translateX(-50%) scale(1.05); box-shadow: 0 15px 50px rgba(255, 94, 98, 0.7); }

        /* Battle Overlay */
        #battle-ui {
            position: absolute; bottom: 10%; left: 50%; transform: translateX(-50%);
            display: none; flex-direction: column; align-items: center; z-index: 50;
            pointer-events: auto; width: 100%;
        }
        .battle-msg {
            font-size: 32px; color: #fff; text-shadow: 0 0 20px rgba(0,0,0,0.8);
            font-family: 'Cinzel', serif;
            opacity: 0; transform: translateY(20px);
            margin-bottom: 20px;
        }
        .battle-controls {
            display: flex; gap: 20px; margin-top: 20px;
            opacity: 0; transform: translateY(20px);
        }
        .battle-btn {
            background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.3);
            color: white; padding: 15px 30px; border-radius: 8px; cursor: pointer;
            font-family: 'Cinzel'; font-size: 14px; text-transform: uppercase;
            transition: all 0.2s; backdrop-filter: blur(5px);
            display: flex; flex-direction: column; align-items: center; gap: 5px;
        }
        .battle-btn:hover { transform: translateY(-5px); border-color: white; background: rgba(0,0,0,0.8); }
        .battle-btn i { font-size: 20px; margin-bottom: 5px; }

        /* Cinematic Curtains */
        .curtain {
            position: fixed; top: 0; height: 100%; width: 51%; background: #0f172a;
            z-index: 200; transition: transform 1.5s cubic-bezier(0.77, 0, 0.175, 1);
            transform: scaleX(0);
        }
        #curtain-left { left: 0; transform-origin: left; }
        #curtain-right { right: 0; transform-origin: right; }
        .curtain.closed { transform: scaleX(1); }

        /* Modal */
        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(8px);
            z-index: 100; display: none; justify-content: center; align-items: center;
        }
        .modal-card {
            background: #fff; padding: 50px; border-radius: 20px;
            text-align: center; max-width: 450px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            border: 1px solid rgba(0,0,0,0.1);
        }
        .modal-card h2 { font-size: 36px; margin-bottom: 10px; background: -webkit-linear-gradient(#4facfe, #00f2fe); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #ffffff, #e0f7fa); color: #0288d1; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-family: 'Cinzel', serif; letter-spacing: 2px;
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <!-- Cinematic Curtains -->
    <div id="curtain-left" class="curtain"></div>
    <div id="curtain-right" class="curtain"></div>

    <div id="loader">
        <h2 style="margin-bottom: 10px;">Forging Realms v2.5</h2>
        <div style="font-size: 12px; opacity: 0.6;">Illuminating the Void...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <!-- Top Stats -->
        <div class="glass-panel" id="top-bar">
            <div class="stat-badge">
                <div class="stat-header">
                    <span style="color:var(--courage)"><i class="fas fa-tree"></i> COURAGE</span>
                    <span id="val-courage">0/0</span>
                </div>
                <div class="stat-bar-container">
                    <div class="stat-fill" id="bar-courage" style="background: var(--courage)"></div>
                </div>
            </div>
            <div class="stat-badge">
                <div class="stat-header">
                    <span style="color:var(--strength)"><i class="fas fa-fire"></i> STRENGTH</span>
                    <span id="val-strength">0/0</span>
                </div>
                <div class="stat-bar-container">
                    <div class="stat-fill" id="bar-strength" style="background: var(--strength)"></div>
                </div>
            </div>
            <div class="stat-badge">
                <div class="stat-header">
                    <span style="color:var(--intellect)"><i class="fas fa-cube"></i> INTELLECT</span>
                    <span id="val-intellect">0/0</span>
                </div>
                <div class="stat-bar-container">
                    <div class="stat-fill" id="bar-intellect" style="background: var(--intellect)"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toggle Button for Scroll -->
    <div id="toggle-scroll-btn" onclick="toggleScroll()">
        <i class="fas fa-scroll"></i>
    </div>

    <!-- Pirate Scroll (Task Panel) -->
    <div id="scroll-container">
        <div class="scroll-body">
            <div class="scroll-header">
                <h2 class="fantasy-font" id="scroll-title">Captain's Log</h2>
                <div class="scroll-date" id="current-date">October 24th, Year of the Sky</div>
            </div>
            <div id="task-list">
                <!-- Tasks injected here -->
            </div>
            <div style="margin-top: 15px; border-top: 1px dashed var(--ink-light); padding-top: 15px;">
                <input type="text" class="scroll-input" id="task-input" placeholder="Draft new orders..." autocomplete="off">
                <div class="input-group" style="display: flex; gap: 5px; margin-top: 10px;">
                    <div class="select-wrapper">
                        <select id="task-type" class="scroll-input">
                            <option value="courage">Whispering Woods</option>
                            <option value="strength">Iron Sanctum</option>
                            <option value="intellect">Citadel of Logic</option>
                            <option value="campfire">Resting Grounds</option>
                        </select>
                    </div>
                    <button class="scroll-btn" onclick="addTask()">ADD</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Center Labels -->
    <div id="biome-label">
        <h1 id="biome-name">Title</h1>
        <p id="biome-desc">Description</p>
    </div>

    <!-- Actions -->
    <button id="back-btn" onclick="returnToMap()"><i class="fas fa-chevron-left"></i> [ESC] Return</button>
    <button id="action-btn" class="fantasy-font" onclick="initiateBattle()">Storm Ritual</button>

    <!-- Battle UI -->
    <div id="battle-ui">
        <div class="battle-msg" id="battle-msg">The Ancient Anomaly Awakens...</div>
        <div class="battle-controls" id="battle-controls">
            <button class="battle-btn" onclick="performAttack('courage')" style="border-color:var(--courage)">
                <i class="fas fa-shield-alt" style="color:var(--courage)"></i> Bravery
            </button>
            <button class="battle-btn" onclick="performAttack('strength')" style="border-color:var(--strength)">
                <i class="fas fa-gavel" style="color:var(--strength)"></i> Force
            </button>
            <button class="battle-btn" onclick="performAttack('intellect')" style="border-color:var(--intellect)">
                <i class="fas fa-brain" style="color:var(--intellect)"></i> Logic
            </button>
        </div>
    </div>

    <!-- Modal -->
    <div id="modal-overlay">
        <div class="modal-card">
            <h2 id="modal-title" class="fantasy-font">Victory</h2>
            <p id="modal-msg" style="line-height: 1.6; color: #555;">The realm prospers.</p>
            <button class="scroll-btn" style="margin-top: 20px; font-size: 16px; padding: 10px 30px;" onclick="closeModal()">Continue</button>
        </div>
    </div>

<script>
    /* =========================================
       GAME STATE & CONFIG
       ========================================= */
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    document.getElementById('current-date').innerText = new Date().toLocaleDateString('en-US', options);

    const state = {
        tasks: [
            { text: "Visit the Resting Grounds", type: "campfire", completed: false },
            { text: "Scout the Whispering Woods", type: "courage", completed: false },
            { text: "Visit the Iron Sanctum", type: "strength", completed: false },
            { text: "Explore the Citadel of Logic", type: "intellect", completed: false }
        ],
        view: 'map',
        isBattling: false,
        mobs: [],
        banners: [], 
        highlightedBiome: null,
        lavaHeart: null,
        bossParts: [],
        lastLook: {x:0, y:0, z:0}
    };

    const CONFIG = {
        colors: {
            skyTop: 0x6dd5fa,
            skyBottom: 0xb2fefa,
            stormTop: 0x0f172a,
            stormBottom: 0x1e293b,
            
            forest: 0x4ade80,
            lava: 0xf87171,
            citadel: 0x60a5fa,
            campfire: 0xffaa00
        }
    };

    const BIOME_DATA = {
        forest: { 
            name: "Whispering Woods", 
            stat: "courage", 
            color: CONFIG.colors.forest,
            titleColor: "#4ade80", 
            desc: "Forge Courage", 
            font: "'Cinzel', serif" 
        },
        lava: { 
            name: "Iron Sanctum", 
            stat: "strength", 
            color: CONFIG.colors.lava,
            titleColor: "#f87171",  
            desc: "Build Strength",
            font: "'Cinzel', serif"
        },
        citadel: { 
            name: "Citadel of Logic", 
            stat: "intellect", 
            color: CONFIG.colors.citadel,
            titleColor: "#60a5fa", 
            desc: "Sharpen Intellect",
            font: "'Cinzel', serif"
        },
        campfire: {
            name: "The Resting Grounds",
            stat: "campfire",
            color: 0xffaa00,
            titleColor: "#ffaa00",
            desc: "Discipline & Promise",
            font: "'Cinzel', serif"
        }
    };

    /* =========================================
       THREE.JS SETUP
       ========================================= */
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    
    scene.background = new THREE.Color(CONFIG.colors.skyBottom);
    scene.fog = new THREE.Fog(CONFIG.colors.skyBottom, 30, 150);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    // Initial camera position will be handled by switchView('map') logic
    camera.position.set(0, 50, 70); 
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9);
    hemiLight.position.set(0, 50, 0);
    scene.add(hemiLight);

    const sunLight = new THREE.DirectionalLight(0xffdfba, 1.2);
    sunLight.position.set(50, 80, 30);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 200;
    scene.add(sunLight);

    // Interactive Cursor Light (The "Lantern")
    const cursorLight = new THREE.PointLight(0xffe0b2, 1.5, 20);
    cursorLight.position.set(0, 10, 0);
    scene.add(cursorLight);

    /* =========================================
       ASSET GENERATION (Voxel System)
       ========================================= */
    const boxGeo = new THREE.BoxGeometry(1, 1, 1);
    
    function createVoxel(color, x, y, z, parent, scale={x:1,y:1,z:1}) {
        const mat = new THREE.MeshStandardMaterial({ 
            color: color, 
            roughness: 0.8, 
            flatShading: true 
        });
        const mesh = new THREE.Mesh(boxGeo, mat);
        mesh.position.set(x, y, z);
        mesh.scale.set(scale.x, scale.y, scale.z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        if(parent) parent.add(mesh);
        return mesh;
    }

    function createEmissiveVoxel(color, x, y, z, parent, scale={x:1,y:1,z:1}, intensity=1) {
        const mat = new THREE.MeshStandardMaterial({ 
            color: color, 
            emissive: color, 
            emissiveIntensity: intensity, 
            flatShading: true,
            roughness: 0.2
        });
        const mesh = new THREE.Mesh(boxGeo, mat);
        mesh.position.set(x, y, z);
        mesh.scale.set(scale.x, scale.y, scale.z);
        mesh.castShadow = true;
        if(parent) parent.add(mesh);
        return mesh;
    }

    /* =========================================
       WORLD BUILDER
       ========================================= */
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    const biomes = {
        forest: new THREE.Group(),
        lava: new THREE.Group(),
        citadel: new THREE.Group(),
        campfire: new THREE.Group() // New Biome
    };
    
    biomes.forest.position.set(-20, 0, 10);
    biomes.lava.position.set(20, -2, 10);
    biomes.citadel.position.set(0, 6, -15);
    biomes.campfire.position.set(0, -2, 5); // Central position

    biomes.forest.userData = { id: 'forest', baseY: 0 };
    biomes.lava.userData = { id: 'lava', baseY: -2 };
    biomes.citadel.userData = { id: 'citadel', baseY: 6 };
    biomes.campfire.userData = { id: 'campfire', baseY: -2 };

    worldGroup.add(biomes.forest, biomes.lava, biomes.citadel, biomes.campfire);

    // --- 1. Whispering Woods (Preserved) ---
    function buildForest() {
        const g = biomes.forest;
        for(let x=-7; x<7; x++) for(let z=-7; z<7; z++) {
            if(x*x+z*z > 40) continue;
            const col = Math.random() > 0.8 ? 0x388e3c : 0x2e7d32; 
            createVoxel(col, x, 0, z, g); 
            createVoxel(0x5d4037, x, -1, z, g); 
            if(Math.random()>0.85) createVoxel(0x4e342e, x, -2-Math.random(), z, g, {x:0.5,y:2,z:0.5});
        }
        
        for(let i=0; i<15; i++) {
            const tx=(Math.random()*10-5), tz=(Math.random()*10-5);
            createVoxel(0x3e2723, tx, 1.5, tz, g, {x:0.6, y:3, z:0.6}); 
            createVoxel(0x4ade80, tx, 3.5, tz, g, {x:1.6, y:1.5, z:1.6}); 
            if(Math.random()>0.7) createEmissiveVoxel(0xffff00, tx+0.5, 4, tz, g, {x:0.2,y:0.2,z:0.2}, 2);
            if(Math.random() > 0.5) createVoxel(0x22c55e, tx + 1, 0.5, tz + 1, g, {x:0.8, y:0.8, z:0.8});
        }

        const pGeo = new THREE.BufferGeometry();
        const pPos = [];
        for(let i=0; i<40; i++) pPos.push((Math.random()-0.5)*12, Math.random()*6+2, (Math.random()-0.5)*12);
        pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
        const fireflies = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0xccff00, size:0.25, transparent:true}));
        g.add(fireflies);
        g.userData.particles = fireflies;

        // Mobs: Rabbits
        for(let i=0; i<6; i++) {
            const rabbit = new THREE.Group();
            createVoxel(0xffffff, 0, 0.25, 0, rabbit, {x:0.4, y:0.4, z:0.6}); 
            createVoxel(0xffffff, 0, 0.55, 0.2, rabbit, {x:0.3, y:0.3, z:0.3}); 
            createVoxel(0xffc0cb, -0.1, 0.8, 0.2, rabbit, {x:0.1, y:0.5, z:0.1});
            createVoxel(0xffc0cb, 0.1, 0.8, 0.2, rabbit, {x:0.1, y:0.5, z:0.1});
            createVoxel(0xffffff, 0, 0.3, -0.35, rabbit, {x:0.15, y:0.15, z:0.15});
            createVoxel(0x000000, 0.1, 0.6, 0.36, rabbit, {x:0.05, y:0.05, z:0.02}); // Eye
            createVoxel(0x000000, -0.1, 0.6, 0.36, rabbit, {x:0.05, y:0.05, z:0.02}); // Eye
            createVoxel(0xffa07a, 0, 0.45, 0.36, rabbit, {x:0.05, y:0.05, z:0.02}); // Mouth/Nose
            
            rabbit.position.set((Math.random()-0.5)*8, 1, (Math.random()-0.5)*8);
            rabbit.userData = { type: 'rabbit', baseY: 1, state: 'idle', timer: Math.random() * 2, jumpTarget: new THREE.Vector3() };
            g.add(rabbit);
            state.mobs.push(rabbit);
        }
    }

    // --- 2. IRON SANCTUM (Preserved) ---
    function buildLava() {
        const g = biomes.lava;
        for(let x=-8; x<8; x++) for(let z=-8; z<8; z++) {
            if(x*x+z*z > 50) continue;
            const isRiver = Math.abs(x*0.5 + Math.sin(z*0.5)*1.5) < 1.5;
            if(isRiver && x*x+z*z < 45) {
                 const m = createEmissiveVoxel(0xff4500, x, -0.5, z, g, {x:1,y:0.8,z:1}, 0.8);
                 m.userData.isLava = true; m.userData.origY = -0.5;
            } else {
                const h = Math.random() * 0.8;
                createVoxel(0x1a1a1a, x, h, z, g, {x:1, y:1+h, z:1});
            }
            createVoxel(0x0f0f0f, x, -1.5, z, g); 
        }
        
        const heartGroup = new THREE.Group();
        heartGroup.position.set(0, 3, 0);
        g.add(heartGroup);
        const coreGeo = new THREE.IcosahedronGeometry(1.2, 1);
        const coreMat = new THREE.MeshStandardMaterial({color: 0xff4500, emissive: 0xff0000, emissiveIntensity: 3, roughness: 0.1, flatShading: true});
        const core = new THREE.Mesh(coreGeo, coreMat);
        heartGroup.add(core);
        const shell = new THREE.Mesh(new THREE.IcosahedronGeometry(1.8, 0), new THREE.MeshStandardMaterial({color: 0x000000, transparent: true, opacity: 0.4, wireframe: true}));
        heartGroup.add(shell);
        const pLight = new THREE.PointLight(0xff0000, 2, 15);
        heartGroup.add(pLight);
        state.lavaHeart = { group: heartGroup, core: core, light: pLight };

        // Mobs: Slimes
        for(let i=0; i<4; i++) {
            const slime = new THREE.Group();
            createVoxel(0x333333, 0, 0.4, 0, slime, {x:0.8, y:0.8, z:0.8});
            createEmissiveVoxel(0xff4500, 0, 0.4, 0.41, slime, {x:0.4, y:0.4, z:0.1}, 2); 
            slime.position.set((Math.random()-0.5)*8, 1, (Math.random()-0.5)*8);
            slime.userData = { type: 'slime', baseY: 1, timer: Math.random()*2, dir: new THREE.Vector3((Math.random()-0.5)*0.02, 0, (Math.random()-0.5)*0.02) };
            g.add(slime);
            state.mobs.push(slime);
        }
    }

    // --- 3. CITADEL OF LOGIC (Preserved) ---
    function buildCitadel() {
        const g = biomes.citadel;
        g.children = []; // Clear old

        // 1. Base Platform (Clean Marble)
        for(let x=-6; x<6; x++) for(let z=-6; z<6; z++) {
            const dist = Math.sqrt(x*x + z*z);
            if(dist > 5.5) continue;
            createVoxel(0xf8fafc, x, 0, z, g, {x:1, y:1, z:1});
            createVoxel(0x94a3b8, x, -1, z, g, {x:0.9, y:1, z:0.9}); // darker underside
        }

        // 2. Main Castle Structure (Sharp & Vertical)
        const castle = new THREE.Group();
        castle.position.set(0, 0.5, 0);
        g.add(castle);

        // Central Spire Base
        createVoxel(0xe2e8f0, 0, 4, 0, castle, {x:3, y:8, z:3});
        
        // Needle Spires (Using ConeGeometry for sharpness)
        function createSpire(x, z, height, width, color) {
            const geo = new THREE.ConeGeometry(width, height, 4);
            const mat = new THREE.MeshStandardMaterial({color: color, flatShading: true, roughness: 0.2});
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, height/2 + 8, z);
            castle.add(mesh);
            
            // Glowing Tip
            const tipGeo = new THREE.ConeGeometry(width/4, 1, 4);
            const tipMat = new THREE.MeshBasicMaterial({color: 0x60a5fa});
            const tip = new THREE.Mesh(tipGeo, tipMat);
            tip.position.set(0, height/2 + 0.5, 0);
            mesh.add(tip);
        }

        // Main Spire
        createSpire(0, 0, 12, 2.5, 0x1e3a8a); // Deep Blue
        // Side Spires
        createSpire(-2.5, -2.5, 8, 1, 0x2563eb);
        createSpire(2.5, -2.5, 8, 1, 0x2563eb);
        createSpire(-2.5, 2.5, 8, 1, 0x2563eb);
        createSpire(2.5, 2.5, 8, 1, 0x2563eb);

        // 3. Heavenly Gates (Always Open)
        const gate = new THREE.Group();
        gate.position.set(0, 1, 4.5);
        // Pillars
        createVoxel(0xffffff, -1.5, 2, 0, gate, {x:0.5, y:4, z:0.5});
        createVoxel(0xffffff, 1.5, 2, 0, gate, {x:0.5, y:4, z:0.5});
        // Arch
        createVoxel(0xffffff, 0, 4.2, 0, gate, {x:3.5, y:0.5, z:0.5});
        // Glowing Energy
        const lightPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(3, 4),
            new THREE.MeshBasicMaterial({color: 0x60a5fa, side: THREE.DoubleSide, transparent: true, opacity: 0.3})
        );
        lightPlane.position.y = 2;
        gate.add(lightPlane);
        castle.add(gate);

        // 4. Floating Outer Walls
        const wallRing = new THREE.Group();
        for(let i=0; i<12; i++) {
            const angle = (i/12) * Math.PI * 2;
            const segment = createVoxel(0xcbd5e1, Math.cos(angle)*7, 0, Math.sin(angle)*7, wallRing, {x:1.5, y:2, z:0.5});
            segment.rotation.y = -angle;
            // Float animation handled in update
        }
        g.add(wallRing);
        g.userData.wallRing = wallRing;

        // Mobs: Scholars
        for(let i=0; i<3; i++) {
            const wiz = new THREE.Group();
            createVoxel(0x1e3a8a, 0, 0.75, 0, wiz, {x:0.5, y:1.5, z:0.5}); // Robe
            createVoxel(0xffd700, 0, 1.6, 0, wiz, {x:0.3, y:0.3, z:0.3}); // Head
            createSpire(0, 0, 0.8, 0.2, 0x60a5fa); // Hat (reusing logic conceptually, implementing manually)
            const hat = createVoxel(0x60a5fa, 0, 1.9, 0, wiz, {x:0.2, y:0.4, z:0.2});
            wiz.position.set((Math.random()-0.5)*4, 1, (Math.random()-0.5)*4);
            g.add(wiz);
            state.mobs.push({userData: {type: 'static', obj: wiz}});
        }
    }

    // --- 4. BIOME: CAMPFIRE / RESTING GROUNDS (Preserved) ---
    function buildCampfire() {
        const g = biomes.campfire;
        
        // Base Island (Rounded, Grassy, Earthy)
        for(let x=-5; x<5; x++) for(let z=-5; z<5; z++) {
            if(x*x + z*z > 20) continue;
            createVoxel(0x5c8001, x, 0, z, g); // Dark warm grass
            createVoxel(0x3e2723, x, -1, z, g); // Dirt
        }

        // Central Campfire
        const fireGroup = new THREE.Group();
        // Logs
        createVoxel(0x5d4037, 0.8, 0.2, 0, fireGroup, {x:1.5, y:0.3, z:0.3}).rotation.y = Math.random();
        createVoxel(0x5d4037, -0.8, 0.2, 0.2, fireGroup, {x:1.5, y:0.3, z:0.3}).rotation.y = Math.random();
        createVoxel(0x5d4037, 0, 0.2, 0.8, fireGroup, {x:1.5, y:0.3, z:0.3}).rotation.y = Math.PI/2 + Math.random();
        
        // Fire Particles (Simple Geometry cluster)
        for(let i=0; i<5; i++) {
            createEmissiveVoxel(0xffaa00, (Math.random()-0.5)*0.5, 0.5+Math.random()*0.5, (Math.random()-0.5)*0.5, fireGroup, {x:0.2, y:0.2, z:0.2}, 2);
        }
        
        // Light
        const fireLight = new THREE.PointLight(0xffaa00, 2, 10);
        fireLight.position.y = 1;
        fireGroup.add(fireLight);
        g.add(fireGroup);
        g.userData.fireLight = fireLight;

        // Tents & Bedrolls
        const tentPos = [{x:-3, z:2}, {x:3, z:-1}, {x:-1, z:-3}];
        tentPos.forEach(p => {
            const tent = new THREE.Group();
            tent.position.set(p.x, 0.5, p.z);
            tent.rotation.y = Math.atan2(-p.x, -p.z); // Face center
            // Canvas
            const t1 = createVoxel(0xd4a373, 0, 0.5, 0, tent, {x:1.5, y:1, z:1.5});
            t1.rotation.x = Math.PI/4;
            // Bedroll
            createVoxel(0x8d6e63, 0, 0.1, 0.5, tent, {x:0.8, y:0.2, z:1.2});
            g.add(tent);
        });

        // Resting Adventurers
        for(let i=0; i<3; i++) {
            const adv = new THREE.Group();
            createVoxel(0x8d6e63, 0, 0.4, 0, adv, {x:0.5, y:0.6, z:0.5}); // Body sitting
            createVoxel(0xffcc80, 0, 0.9, 0, adv, {x:0.3, y:0.3, z:0.3}); // Head
            adv.position.set((Math.random()-0.5)*3, 0.3, (Math.random()-0.5)*3);
            adv.lookAt(0,0,0);
            g.add(adv);
        }

        // Fireflies
        const pGeo = new THREE.BufferGeometry();
        const pPos = [];
        for(let i=0; i<20; i++) pPos.push((Math.random()-0.5)*6, Math.random()*3, (Math.random()-0.5)*6);
        pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
        const flies = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0xffaa00, size:0.1, transparent:true}));
        g.add(flies);
        g.userData.particles = flies;
    }

    // --- 5. BRIDGES (Connecting to Center) ---
    function buildBridges() {
        const bridgeGroup = new THREE.Group();
        scene.add(bridgeGroup);
        
        function makeBridge(start, end) {
            const dist = start.distanceTo(end);
            const steps = Math.floor(dist * 1.5);
            for(let i=0; i<=steps; i++) {
                const t = i/steps;
                const p = new THREE.Vector3().lerpVectors(start, end, t);
                // Arch effect
                p.y += Math.sin(t * Math.PI) * 1.0; 
                createVoxel(0x8d6e63, p.x, p.y, p.z, bridgeGroup, {x:1, y:0.2, z:1});
                
                // Lanterns
                if(i%8===0 && i!==0 && i!==steps) {
                    createEmissiveVoxel(0xffaa00, p.x, p.y+1, p.z, bridgeGroup, {x:0.2,y:0.4,z:0.2}, 1);
                }
            }
        }

        // Connect Center (Campfire) to all 3 nodes
        makeBridge(biomes.campfire.position, biomes.forest.position);
        makeBridge(biomes.campfire.position, biomes.lava.position);
        makeBridge(biomes.campfire.position, biomes.citadel.position);
    }

    buildForest(); buildLava(); buildCitadel(); buildCampfire(); buildBridges();

    // 6. Cloud System & Stars (Enhanced for Immersion)
    const cloudParticles = [];
    function createClouds() {
        const cloudGeo = new THREE.IcosahedronGeometry(1, 0);
        const cloudMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, flatShading: true });
        
        // Massive distant cloud floor
        const ocean = new THREE.InstancedMesh(cloudGeo, cloudMat, 300);
        const dummy = new THREE.Object3D();
        for(let i=0; i<300; i++) {
            dummy.position.set((Math.random()-0.5)*200, -25 + Math.random()*5, (Math.random()-0.5)*150);
            const s = 4 + Math.random()*6;
            dummy.scale.set(s*1.5, s*0.8, s);
            dummy.updateMatrix();
            ocean.setMatrixAt(i, dummy.matrix);
        }
        scene.add(ocean);

        // Drifting clouds
        for(let i=0; i<30; i++) {
            const c = new THREE.Mesh(cloudGeo, cloudMat);
            c.position.set((Math.random()-0.5)*100, Math.random()*15 - 5, (Math.random()-0.5)*80);
            c.scale.setScalar(2 + Math.random());
            c.userData.speed = 0.02 + Math.random()*0.02;
            scene.add(c);
            cloudParticles.push(c);
        }

        // Starfield / Distant Dust
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<1000; i++) {
            starPos.push((Math.random()-0.5)*400, (Math.random()-0.5)*200 + 50, (Math.random()-0.5)*400);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.5, transparent: true, opacity: 0.6});
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);
        
        // Slight star rotation handle
        scene.userData.stars = stars;
    }
    createClouds();

    /* =========================================
       BOSS & BATTLE ASSETS
       ========================================= */
    const bossGroup = new THREE.Group();
    scene.add(bossGroup);
    bossGroup.visible = false;

    function buildBoss() {
        // Core: Pulsing unstable energy
        const core = createEmissiveVoxel(0xff0000, 0, 0, 0, bossGroup, {x:2, y:2, z:2}, 5);
        state.bossParts.push({mesh: core, type: 'core', rot: {x:0.01, y:0.02}});

        // Inner Ring: Jagged Rock Plates
        const ring1 = new THREE.Group();
        for(let i=0; i<8; i++) {
            const angle = (i/8)*Math.PI*2;
            createVoxel(0x1a1a1a, Math.cos(angle)*3, (Math.random()-0.5)*2, Math.sin(angle)*3, ring1, {x:1, y:2, z:1});
        }
        bossGroup.add(ring1);
        state.bossParts.push({mesh: ring1, type: 'ring', rot: {x:0.02, y:0.01, z:0.01}});

        // Outer Ring: Floating Debris & Smoke
        const ring2 = new THREE.Group();
        for(let i=0; i<12; i++) {
            const angle = (i/12)*Math.PI*2;
            const dist = 5 + Math.random();
            const debris = createVoxel(0x333333, Math.cos(angle)*dist, (Math.random()-0.5)*4, Math.sin(angle)*dist, ring2, {x:0.5, y:0.5, z:0.5});
            debris.rotation.set(Math.random(), Math.random(), Math.random());
        }
        bossGroup.add(ring2);
        state.bossParts.push({mesh: ring2, type: 'ring', rot: {x:-0.01, y:-0.03, z:0.0}});

        // Tentacles / Energy Arcs
        for(let i=0; i<3; i++) {
            const arm = new THREE.Group();
            createEmissiveVoxel(0xff3d00, 2, 0, 0, arm, {x:4, y:0.2, z:0.2}, 2);
            arm.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
            bossGroup.add(arm);
            state.bossParts.push({mesh: arm, type: 'arm', rot: {x:0.05, y:0.05}});
        }
    }
    buildBoss();

    setTimeout(() => {
        document.getElementById('loader').style.opacity = 0;
        setTimeout(() => document.getElementById('loader').style.display='none', 1000);
        renderTasks();
    }, 1500);

    /* =========================================
       ANIMATION LOOP & CONTROL
       ========================================= */
    const clock = new THREE.Clock();
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const cursor3D = new THREE.Vector3();
    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -5); // Plane for raycasting cursor height

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        // 1. World Drift (Immersion)
        // Very slow, majestic rotation of the entire world
        if(!state.isBattling) {
            worldGroup.rotation.y = Math.sin(time * 0.05) * 0.05;
        }

        // 2. Parallax Camera (Control/Juice)
        if(state.view === 'map') {
            const targetX = mouse.x * 5; // Slight left/right parallax
            const targetY = 50 + (mouse.y * 5); // Slight up/down parallax
            
            // Smoothly interpolate current pos to target
            camera.position.x += (targetX - camera.position.x) * 0.05;
            camera.position.y += (targetY - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);
        }

        // 3. Cursor Light (Immersion/Feedback)
        // Move the 3D cursor light to where the mouse is pointing on a theoretical plane
        raycaster.setFromCamera(mouse, camera);
        const target = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, target);
        if(target) {
            cursorLight.position.x += (target.x - cursorLight.position.x) * 0.1;
            cursorLight.position.z += (target.z - cursorLight.position.z) * 0.1;
            // Float light above the world
            cursorLight.position.y = 15 + Math.sin(time) * 2; 
        }

        // Star Movement
        if(scene.userData.stars) {
            scene.userData.stars.rotation.y = time * 0.005;
        }

        // Biome Floats
        biomes.citadel.position.y = 6 + Math.sin(time*0.5)*0.5;
        biomes.campfire.position.y = -2 + Math.sin(time*0.3)*0.3;
        
        // Citadel Wall Ring Spin
        if(biomes.citadel.userData.wallRing) {
            biomes.citadel.userData.wallRing.rotation.y = time * 0.1;
            biomes.citadel.userData.wallRing.position.y = Math.sin(time) * 0.5;
        }

        // Campfire Flicker
        if(biomes.campfire.userData.fireLight) {
            biomes.campfire.userData.fireLight.intensity = 2 + Math.sin(time*20)*0.5 + Math.random()*0.5;
        }

        // Lava Heart Pulse
        if(state.lavaHeart) {
            const pulse = 1 + Math.sin(time * 10) * 0.1; 
            state.lavaHeart.core.scale.set(pulse, pulse, pulse);
            state.lavaHeart.light.intensity = 2 + Math.random();
            state.lavaHeart.group.rotation.y = time * 0.5;
        }

        // Clouds Move
        cloudParticles.forEach(c => {
            c.position.x += c.userData.speed;
            if(c.position.x > 80) c.position.x = -80;
        });

        // Particles
        const particles = [biomes.forest.userData.particles, biomes.campfire.userData.particles].flat();
        particles.forEach(p => {
            if(!p) return;
            const pos = p.geometry.attributes.position.array;
            for(let i=1; i<pos.length; i+=3) {
                pos[i] += Math.sin(time + pos[i-1])*0.02; // Float up/down
            }
            p.geometry.attributes.position.needsUpdate = true;
        });

        // Boss Animation (Chaotic)
        if(state.isBattling) {
            bossGroup.position.y = Math.sin(time)*2;
            state.bossParts.forEach(p => {
                p.mesh.rotation.x += p.rot.x;
                p.mesh.rotation.y += p.rot.y;
                if(p.rot.z) p.mesh.rotation.z += p.rot.z;
                if(p.type === 'core') {
                    const s = 1 + Math.sin(time*15)*0.2;
                    p.mesh.scale.set(s,s,s);
                }
            });
        }

        // Mob Animation
        state.mobs.forEach(mob => {
            if(mob.userData.type === 'rabbit') {
                mob.userData.timer -= delta;
                if(mob.userData.timer <= 0) {
                    if(mob.userData.state === 'idle') {
                        mob.userData.state = 'jump';
                        mob.userData.timer = 0.5;
                        mob.userData.jumpTarget.set((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2);
                        mob.rotation.y = Math.atan2(mob.userData.jumpTarget.x, mob.userData.jumpTarget.z);
                    } else {
                        mob.userData.state = 'idle';
                        mob.userData.timer = 1 + Math.random() * 2;
                        mob.position.y = mob.userData.baseY;
                    }
                }
                if(mob.userData.state === 'jump') {
                    const progress = 1 - (mob.userData.timer / 0.5);
                    mob.position.y = mob.userData.baseY + Math.sin(progress * Math.PI) * 0.8;
                    mob.position.x += mob.userData.jumpTarget.x * 0.02;
                    mob.position.z += mob.userData.jumpTarget.z * 0.02;
                }
            } 
            else if(mob.userData.type === 'slime') {
                mob.userData.timer -= delta;
                if(mob.userData.timer <= 0) {
                    const angle = Math.random() * Math.PI * 2; 
                    const speed = 0.03;
                    mob.userData.dir.set(Math.cos(angle)*speed, 0, Math.sin(angle)*speed);
                    mob.userData.timer = 2 + Math.random();
                }
                const nextX = mob.position.x + mob.userData.dir.x;
                const nextZ = mob.position.z + mob.userData.dir.z;
                if(nextX*nextX + nextZ*nextZ < 49) mob.position.add(mob.userData.dir);
                else mob.userData.dir.multiplyScalar(-1);
                mob.position.y = mob.userData.baseY + Math.abs(Math.sin(time * 5)) * 0.3;
            }
        });

        renderer.render(scene, camera);
    }
    animate();

    /* =========================================
       INTERACTION & CAMERA
       ========================================= */
    const VIEWS = {
        map: { pos: {x:0, y:50, z:70}, look: {x:0, y:0, z:0} },
        forest: { pos: {x:-20, y:12, z:25}, look: {x:-20, y:0, z:10} },
        lava: { pos: {x:20, y:12, z:25}, look: {x:20, y:-2, z:10} },
        citadel: { pos: {x:0, y:20, z:5}, look: {x:0, y:12, z:-15} }, 
        campfire: { pos: {x:0, y:5, z:15}, look: {x:0, y:0, z:5} },
        battle: { pos: {x:0, y:10, z:40}, look: {x:0, y:0, z:0} } 
    };

    function switchView(viewName) {
        state.view = viewName;
        const target = VIEWS[viewName];
        
        // Reset world rotation when focusing
        gsap.to(worldGroup.rotation, {y: 0, duration: 1});

        gsap.to(camera.position, {
            x: target.pos.x, y: target.pos.y, z: target.pos.z,
            duration: 1.5, ease: "power2.inOut"
        });
        
        const temp = { x: state.lastLook?.x||0, y: state.lastLook?.y||0, z: state.lastLook?.z||0 };
        gsap.to(temp, {
            x: target.look.x, y: target.look.y, z: target.look.z,
            duration: 1.5, ease: "power2.inOut",
            onUpdate: () => camera.lookAt(temp.x, temp.y, temp.z),
            onComplete: () => state.lastLook = target.look
        });

        // UI State
        const isMap = viewName === 'map';
        document.getElementById('back-btn').style.display = isMap ? 'none' : 'block';
        document.getElementById('action-btn').style.display = isMap ? 'block' : 'none';
        
        const scroll = document.getElementById('scroll-container');
        if(!isMap) {
            scroll.classList.add('minimized');
            document.getElementById('toggle-scroll-btn').style.display = 'none';
        } else {
            document.getElementById('toggle-scroll-btn').style.display = 'flex';
            scroll.classList.remove('minimized');
        }

        // Special Scroll Logic for Campfire
        if(viewName === 'campfire') {
            scroll.classList.remove('minimized');
            document.getElementById('scroll-title').innerText = "The Code";
            document.getElementById('task-list').innerHTML = `
                <div style="font-style:italic; padding:10px; text-align:center;">
                    "Discipline is the bridge between goals and accomplishment.<br>
                    Keep your promises to yourself.<br><br>
                    Rest here, but do not linger forever."
                </div>
            `;
            // Hide input
            document.querySelector('.scroll-body > div:last-child').style.display = 'none';
        } else {
            document.getElementById('scroll-title').innerText = "Captain's Log";
            document.querySelector('.scroll-body > div:last-child').style.display = 'block';
            if(isMap) renderTasks(); // Restore task list
        }

        if(!isMap && viewName !== 'battle') {
            const data = BIOME_DATA[viewName];
            const label = document.getElementById('biome-name');
            label.innerText = data.name;
            label.style.fontFamily = data.font;
            label.style.color = data.titleColor;
            label.style.textShadow = `0 0 20px ${data.titleColor}`;
            
            document.getElementById('biome-desc').innerText = data.desc;
            document.getElementById('biome-label').style.opacity = 1;
        } else {
            document.getElementById('biome-label').style.opacity = 0;
        }
    }
    
    window.addEventListener('mousemove', (e) => {
        // Normalize mouse for Raycaster AND Parallax
        mouse.x = (e.clientX/window.innerWidth)*2-1;
        mouse.y = -(e.clientY/window.innerHeight)*2+1;

        if(state.view !== 'map') return;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(worldGroup.children, true);
        
        if(intersects.length > 0) {
            let obj = intersects[0].object;
            while(obj.parent && obj.parent !== worldGroup) obj = obj.parent;
            
            if(obj.userData.id && state.highlightedBiome !== obj) {
                if(state.highlightedBiome) removeHighlight(state.highlightedBiome);
                state.highlightedBiome = obj;
                addHighlight(obj);
                document.body.style.cursor = 'pointer';
            }
        } else {
            if(state.highlightedBiome) {
                removeHighlight(state.highlightedBiome);
                state.highlightedBiome = null;
                document.body.style.cursor = 'default';
            }
        }
    });

    // Keyboard Support (ESC to go back)
    document.addEventListener('keydown', (e) => {
        if(e.key === "Escape" && state.view !== 'map' && !state.isBattling) {
            returnToMap();
        }
    });

    function addHighlight(group) {
        // Sound effect placeholder (Visual pop)
        gsap.to(group.position, { y: group.userData.baseY + 1.5, duration: 0.4, ease: "power2.out" });
        gsap.to(group.scale, { x: 1.05, z: 1.05, duration: 0.4 });
        
        // Intensity up cursor light
        gsap.to(cursorLight, { intensity: 2.5, distance: 30, duration: 0.2 });
    }
    function removeHighlight(group) {
        gsap.to(group.position, { y: group.userData.baseY, duration: 0.4, ease: "power2.out" });
        gsap.to(group.scale, { x: 1, z: 1, duration: 0.4 });
        
        // Dim light
        gsap.to(cursorLight, { intensity: 1.5, distance: 20, duration: 0.2 });
    }

    window.addEventListener('click', (e) => {
        if(e.target.closest('.glass-panel') || e.target.closest('button') || e.target.closest('#scroll-container') || e.target.closest('#toggle-scroll-btn')) return;
        if(state.view === 'map' && !state.isBattling && state.highlightedBiome) {
            switchView(state.highlightedBiome.userData.id);
        }
    });

    window.returnToMap = () => {
        // Reset scroll content if coming from campfire
        if(state.view === 'campfire') renderTasks();
        switchView('map');
    };

    /* =========================================
       UI LOGIC (Tasks & Stats)
       ========================================= */
    function renderTasks() {
        const list = document.getElementById('task-list');
        list.innerHTML = '';
        state.tasks.forEach((t, i) => {
            // Find biome data based on stat type match
            const biomeEntry = Object.values(BIOME_DATA).find(b => b.stat === t.type);
            const colorNum = biomeEntry ? biomeEntry.color : 0x5c4a3b;
            const colorHex = '#' + colorNum.toString(16).padStart(6, '0');
            
            // Create RGBA for background
            const r = (colorNum >> 16) & 255;
            const g = (colorNum >> 8) & 255;
            const b = colorNum & 255;
            const bgStart = `rgba(${r}, ${g}, ${b}, 0.1)`;
            const bgEnd = `rgba(${r}, ${g}, ${b}, 0.05)`;

            const div = document.createElement('div');
            div.className = `task-item ${t.completed?'completed':''}`;
            
            // Enhanced Styling
            div.style.borderLeft = `4px solid ${colorHex}`;
            div.style.background = `linear-gradient(to right, ${bgStart}, ${bgEnd})`;
            
            let icon = 'fa-scroll';
            if(t.type === 'courage') icon = 'fa-tree';
            if(t.type === 'strength') icon = 'fa-fire';
            if(t.type === 'intellect') icon = 'fa-cube';
            if(t.type === 'campfire') icon = 'fa-campground';

            div.innerHTML = `
                <div style="display:flex; align-items:center; gap:10px;">
                    <div style="
                        width: 24px; height: 24px; 
                        background: ${colorHex}; 
                        border-radius: 50%; 
                        display: flex; align-items: center; justify-content: center;
                        color: white; font-size: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    ">
                        <i class="fas ${icon}"></i>
                    </div>
                    <div style="font-weight:bold; color: var(--ink);">${t.text}</div>
                </div>
                <div style="
                    font-family:'Homemade Apple'; 
                    font-size:12px; 
                    color: ${colorHex}; 
                    font-weight: bold;
                ">${t.completed ? 'Done' : 'Pending'}</div>
            `;
            div.onclick = () => toggleTask(i);
            list.appendChild(div);
        });
        updateStats();
    }

    function updateStats() {
        ['courage', 'strength', 'intellect'].forEach(stat => {
            const all = state.tasks.filter(t => t.type === stat);
            const done = all.filter(t => t.completed).length;
            const pct = all.length ? (done / all.length) * 100 : 0;
            document.getElementById(`val-${stat}`).innerText = `${done}/${all.length}`;
            document.getElementById(`bar-${stat}`).style.width = `${pct}%`;
        });
    }

    window.addTask = () => {
        const input = document.getElementById('task-input');
        const type = document.getElementById('task-type').value;
        if(input.value.trim()) {
            state.tasks.push({ text: input.value, type, completed: false });
            input.value = '';
            renderTasks();
        }
    };
    
    // Add task on Enter key
    document.getElementById('task-input').addEventListener('keypress', (e) => {
        if(e.key === 'Enter') addTask();
    });

    window.toggleScroll = () => {
        const scroll = document.getElementById('scroll-container');
        scroll.classList.toggle('minimized');
    };

    function toggleTask(i) {
        state.tasks[i].completed = !state.tasks[i].completed; 
        renderTasks();
        if(state.tasks[i].completed) {
            const type = state.tasks[i].type;
            if(biomes[type]) pulseBiome(biomes[type]);
        }
    }

    function pulseBiome(group) {
        const beam = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 30, 8),
            new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0 })
        );
        beam.position.copy(group.position);
        beam.position.y += 10;
        scene.add(beam);
        gsap.to(beam.material, { opacity: 0.8, duration: 0.2, yoyo: true, repeat: 1 });
        gsap.to(beam.scale, { x: 5, z: 5, duration: 0.5, onComplete: () => scene.remove(beam) });
    }

    /* =========================================
       BATTLE SYSTEM (CINEMATIC)
       ========================================= */
    window.initiateBattle = () => {
        state.isBattling = true;
        // 1. Curtains Close
        document.getElementById('curtain-left').classList.add('closed');
        document.getElementById('curtain-right').classList.add('closed');
        
        // Hide UI
        document.getElementById('ui-layer').classList.add('hidden');
        document.getElementById('action-btn').style.display = 'none';
        document.getElementById('scroll-container').classList.add('minimized');
        document.getElementById('toggle-scroll-btn').style.display = 'none';
        document.body.classList.add('storm-mode');

        // 2. Setup Scene Behind Curtains
        setTimeout(() => {
            switchView('battle');
            bossGroup.visible = true;
            bossGroup.position.set(0, 0, 0);
            bossGroup.scale.set(0.1, 0.1, 0.1);

            // Environment Shift
            const stormColor = new THREE.Color(CONFIG.colors.stormBottom);
            scene.fog.color.copy(stormColor);
            hemiLight.intensity = 0.2;
            cursorLight.intensity = 0; // Hide cursor light in battle
            
            // 3. Curtains Open
            document.getElementById('curtain-left').classList.remove('closed');
            document.getElementById('curtain-right').classList.remove('closed');
            
            // 4. Boss Reveal
            gsap.to(bossGroup.scale, {x:1, y:1, z:1, duration: 2, ease: "back.out(1.7)"});
            
            const battleMsg = document.getElementById('battle-msg');
            const battleControls = document.getElementById('battle-controls');
            const battleUI = document.getElementById('battle-ui');
            
            battleUI.style.display = 'flex';
            battleMsg.innerText = "The Void Stares Back...";
            gsap.to(battleMsg, { opacity: 1, y: 0, duration: 1, delay: 1 });
            gsap.to(battleControls, { opacity: 1, y: 0, duration: 1, delay: 1.5 });

        }, 1600); // Wait for curtain close
    };

    window.performAttack = (type) => {
        // Attack Animation
        const battleMsg = document.getElementById('battle-msg');
        battleMsg.innerText = `Channeling ${type.toUpperCase()}...`;
        
        // Camera Shake
        gsap.to(camera.position, {x:"+=2", duration:0.05, yoyo:true, repeat:5});
        
        // Boss Flash
        bossGroup.traverse(c => {
             if(c.isMesh) {
                c.userData.oldCol = c.material.color.getHex();
                c.material.color.setHex(0xffffff);
            }
        });
        setTimeout(() => {
            bossGroup.traverse(c => {
                if(c.isMesh && c.userData.oldCol) c.material.color.setHex(c.userData.oldCol);
            });
        }, 100);

        // Win Calculation
        const relevantTasks = state.tasks.filter(t => t.type !== 'campfire'); 
        const total = relevantTasks.length;
        const completed = relevantTasks.filter(t => t.completed).length;
        let pct = total > 0 ? completed / total : 0;
        
        // Cap win chance at 95% to allow rare losses
        const winChance = Math.min(pct, 0.95);
        const roll = Math.random();
        const victory = roll < winChance;

        setTimeout(() => {
            endBattle(victory, pct);
        }, 1500);
    };

    function endBattle(victory, pct) {
        if(victory) {
            gsap.to(bossGroup.scale, { x:0, y:0, z:0, duration: 1, ease:"back.in" });
            setTimeout(() => showModal(true, pct), 1500);
        } else {
            // Screen shakes violently
            gsap.to(camera.position, {y:"-=5", duration: 0.5, ease:"bounce.out"});
            setTimeout(() => showModal(false, pct), 1000);
        }
    }
    
    function showModal(victory, pct) {
        document.getElementById('battle-ui').style.display = 'none';
        const modal = document.getElementById('modal-overlay');
        const title = document.getElementById('modal-title');
        const msg = document.getElementById('modal-msg');
        modal.style.display = 'flex';
        
        if(victory) {
            title.innerText = "Storm Cleared";
            const messages = [
                "The darkness recedes. You are stronger now.",
                "Discipline has prevailed.",
                "The world breathes easier today."
            ];
            msg.innerText = messages[Math.floor(Math.random()*messages.length)];
        } else {
            title.innerText = "Retreat";
            if(pct >= 0.9) {
                msg.innerText = "Even with perfect preparation, chaos sometimes wins. This is part of the path. Stand up.";
            } else {
                msg.innerText = "Your resolve was not enough. Complete more tasks and return.";
            }
        }
    }

    window.closeModal = () => {
        document.getElementById('modal-overlay').style.display = 'none';
        
        // Reset Environment
        document.body.classList.remove('storm-mode');
        const skyColor = new THREE.Color(CONFIG.colors.skyBottom);
        gsap.to(scene.fog.color, { r: skyColor.r, g: skyColor.g, b: skyColor.b, duration: 2 });
        hemiLight.intensity = 0.9;
        cursorLight.intensity = 1.5;

        bossGroup.visible = false;
        
        state.isBattling = false;
        document.getElementById('ui-layer').classList.remove('hidden');
        document.getElementById('toggle-scroll-btn').style.display = 'flex';
        document.getElementById('scroll-container').classList.remove('minimized');
        switchView('map');
    };

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>